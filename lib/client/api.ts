/* tslint:disable */
/* eslint-disable */
/**
 * Twitter API v2
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * @type AddOrDeleteRulesRequest
 * @export
 */
export type AddOrDeleteRulesRequest = AddRulesRequest | DeleteRulesRequest;

/**
 * @type AddOrDeleteRulesResponse
 * @export
 */
export type AddOrDeleteRulesResponse = AddRulesResponse | DeleteRulesResponse;

/**
 * A request to add a user-specified stream filtering rule.
 * @export
 * @interface AddRulesRequest
 */
export interface AddRulesRequest {
    /**
     *
     * @type {Array<RuleNoId>}
     * @memberof AddRulesRequest
     */
    add: Array<RuleNoId>;
}
/**
 * A response from adding user-specified stream filtering rules.
 * @export
 * @interface AddRulesResponse
 */
export interface AddRulesResponse {
    /**
     * All user-specified stream filtering rules that were created.
     * @type {Array<Rule>}
     * @memberof AddRulesResponse
     */
    data: Array<Rule>;
    /**
     *
     * @type {RulesResponseMetadata}
     * @memberof AddRulesResponse
     */
    meta: RulesResponseMetadata;
}
/**
 *
 * @export
 * @interface AnimatedGif
 */
export interface AnimatedGif {
    /**
     * The Media Key identifier for this attachment.
     * @type {string}
     * @memberof AnimatedGif
     */
    media_key?: string;
    /**
     * The height of the media in pixels
     * @type {number}
     * @memberof AnimatedGif
     */
    height?: number;
    /**
     * The width of the media in pixels
     * @type {number}
     * @memberof AnimatedGif
     */
    width?: number;
    /**
     *
     * @type {string}
     * @memberof AnimatedGif
     */
    type?: AnimatedGifTypeEnum;
    /**
     *
     * @type {string}
     * @memberof AnimatedGif
     */
    preview_image_url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AnimatedGifTypeEnum {
    AnimatedGif = 'animated_gif'
}

/**
 *
 * @export
 * @interface AnimatedGifAllOf
 */
export interface AnimatedGifAllOf {
    /**
     *
     * @type {string}
     * @memberof AnimatedGifAllOf
     */
    type?: AnimatedGifAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof AnimatedGifAllOf
     */
    preview_image_url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AnimatedGifAllOfTypeEnum {
    AnimatedGif = 'animated_gif'
}

/**
 *
 * @export
 * @interface CashtagEntity
 */
export interface CashtagEntity {
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof CashtagEntity
     */
    start: number;
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof CashtagEntity
     */
    end: number;
    /**
     *
     * @type {string}
     * @memberof CashtagEntity
     */
    tag: string;
}
/**
 * Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
 * @export
 * @interface CashtagFields
 */
export interface CashtagFields {
    /**
     *
     * @type {string}
     * @memberof CashtagFields
     */
    tag: string;
}
/**
 * Your client has gone away.
 * @export
 * @interface ClientDisconnectedProblem
 */
export interface ClientDisconnectedProblem {
    /**
     *
     * @type {string}
     * @memberof ClientDisconnectedProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof ClientDisconnectedProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof ClientDisconnectedProblem
     */
    type?: ClientDisconnectedProblemTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ClientDisconnectedProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsClientDisconnected = 'https://api.twitter.com/2/problems/client-disconnected'
}

/**
 *
 * @export
 * @interface ClientDisconnectedProblemAllOf
 */
export interface ClientDisconnectedProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof ClientDisconnectedProblemAllOf
     */
    type?: ClientDisconnectedProblemAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ClientDisconnectedProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsClientDisconnected = 'https://api.twitter.com/2/problems/client-disconnected'
}

/**
 * A problem that indicates your client is forbidden from making this request.
 * @export
 * @interface ClientForbiddenProblem
 */
export interface ClientForbiddenProblem {
    /**
     *
     * @type {string}
     * @memberof ClientForbiddenProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof ClientForbiddenProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof ClientForbiddenProblem
     */
    type?: ClientForbiddenProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ClientForbiddenProblem
     */
    reason?: ClientForbiddenProblemReasonEnum;
    /**
     *
     * @type {string}
     * @memberof ClientForbiddenProblem
     */
    registration_url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ClientForbiddenProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsClientForbidden = 'https://api.twitter.com/2/problems/client-forbidden'
}
/**
    * @export
    * @enum {string}
    */
export enum ClientForbiddenProblemReasonEnum {
    OfficialClientForbidden = 'official-client-forbidden',
    ClientNotEnrolled = 'client-not-enrolled'
}

/**
 *
 * @export
 * @interface ClientForbiddenProblemAllOf
 */
export interface ClientForbiddenProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof ClientForbiddenProblemAllOf
     */
    type?: ClientForbiddenProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ClientForbiddenProblemAllOf
     */
    reason?: ClientForbiddenProblemAllOfReasonEnum;
    /**
     *
     * @type {string}
     * @memberof ClientForbiddenProblemAllOf
     */
    registration_url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ClientForbiddenProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsClientForbidden = 'https://api.twitter.com/2/problems/client-forbidden'
}
/**
    * @export
    * @enum {string}
    */
export enum ClientForbiddenProblemAllOfReasonEnum {
    OfficialClientForbidden = 'official-client-forbidden',
    ClientNotEnrolled = 'client-not-enrolled'
}

/**
 *
 * @export
 * @interface CommonMediaFields
 */
export interface CommonMediaFields {
    /**
     * The Media Key identifier for this attachment.
     * @type {string}
     * @memberof CommonMediaFields
     */
    media_key?: string;
    /**
     * The height of the media in pixels
     * @type {number}
     * @memberof CommonMediaFields
     */
    height?: number;
    /**
     * The width of the media in pixels
     * @type {number}
     * @memberof CommonMediaFields
     */
    width?: number;
}
/**
 * A problem that indicates something is wrong with the connection
 * @export
 * @interface ConnectionExceptionProblem
 */
export interface ConnectionExceptionProblem {
    /**
     *
     * @type {string}
     * @memberof ConnectionExceptionProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof ConnectionExceptionProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof ConnectionExceptionProblem
     */
    type?: ConnectionExceptionProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ConnectionExceptionProblem
     */
    connection_issue?: ConnectionExceptionProblemConnectionIssueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectionExceptionProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsStreamingConnection = 'https://api.twitter.com/2/problems/streaming-connection'
}
/**
    * @export
    * @enum {string}
    */
export enum ConnectionExceptionProblemConnectionIssueEnum {
    TooManyConnections = 'TooManyConnections',
    ProvisioningSubscription = 'ProvisioningSubscription',
    RuleConfigurationIssue = 'RuleConfigurationIssue'
}

/**
 *
 * @export
 * @interface ConnectionExceptionProblemAllOf
 */
export interface ConnectionExceptionProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof ConnectionExceptionProblemAllOf
     */
    type?: ConnectionExceptionProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ConnectionExceptionProblemAllOf
     */
    connection_issue?: ConnectionExceptionProblemAllOfConnectionIssueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectionExceptionProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsStreamingConnection = 'https://api.twitter.com/2/problems/streaming-connection'
}
/**
    * @export
    * @enum {string}
    */
export enum ConnectionExceptionProblemAllOfConnectionIssueEnum {
    TooManyConnections = 'TooManyConnections',
    ProvisioningSubscription = 'ProvisioningSubscription',
    RuleConfigurationIssue = 'RuleConfigurationIssue'
}

/**
 * Annotation inferred from the tweet text.
 * @export
 * @interface ContextAnnotation
 */
export interface ContextAnnotation {
    /**
     *
     * @type {ContextAnnotationDomainFields}
     * @memberof ContextAnnotation
     */
    domain: ContextAnnotationDomainFields;
    /**
     *
     * @type {ContextAnnotationEntityFields}
     * @memberof ContextAnnotation
     */
    entity: ContextAnnotationEntityFields;
}
/**
 * Represents the data for the context annotation domain.
 * @export
 * @interface ContextAnnotationDomainFields
 */
export interface ContextAnnotationDomainFields {
    /**
     * The unique id for a context annotation domain.
     * @type {string}
     * @memberof ContextAnnotationDomainFields
     */
    id: string;
    /**
     * Name of the context annotation domain.
     * @type {string}
     * @memberof ContextAnnotationDomainFields
     */
    name?: string;
    /**
     * Description of the context annotation domain.
     * @type {string}
     * @memberof ContextAnnotationDomainFields
     */
    description?: string;
}
/**
 * Represents the data for the context annotation entity.
 * @export
 * @interface ContextAnnotationEntityFields
 */
export interface ContextAnnotationEntityFields {
    /**
     * The unique id for a context annotation entity.
     * @type {string}
     * @memberof ContextAnnotationEntityFields
     */
    id: string;
    /**
     * Name of the context annotation entity.
     * @type {string}
     * @memberof ContextAnnotationEntityFields
     */
    name?: string;
    /**
     * Description of the context annotation entity.
     * @type {string}
     * @memberof ContextAnnotationEntityFields
     */
    description?: string;
}
/**
 * A response from deleting user-specified stream filtering rules.
 * @export
 * @interface DeleteRulesRequest
 */
export interface DeleteRulesRequest {
    /**
     *
     * @type {DeleteRulesRequestDelete}
     * @memberof DeleteRulesRequest
     */
    _delete: DeleteRulesRequestDelete;
}
/**
 * IDs and values of all deleted user-specified stream filtering rules.
 * @export
 * @interface DeleteRulesRequestDelete
 */
export interface DeleteRulesRequestDelete {
    /**
     * IDs of all deleted user-specified stream filtering rules.
     * @type {Array<string>}
     * @memberof DeleteRulesRequestDelete
     */
    ids?: Array<string>;
    /**
     * Values of all deleted user-specified stream filtering rules.
     * @type {Array<string>}
     * @memberof DeleteRulesRequestDelete
     */
    values?: Array<string>;
}
/**
 *
 * @export
 * @interface DeleteRulesResponse
 */
export interface DeleteRulesResponse {
    /**
     *
     * @type {RulesResponseMetadata}
     * @memberof DeleteRulesResponse
     */
    meta: RulesResponseMetadata;
}
/**
 * A problem that indicates that the resource requested violates the precepts of this API.
 * @export
 * @interface DisallowedResourceProblem
 */
export interface DisallowedResourceProblem {
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    type?: DisallowedResourceProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    resource_id: string;
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    resource_type: DisallowedResourceProblemResourceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    section: DisallowedResourceProblemSectionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DisallowedResourceProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsDisallowedResource = 'https://api.twitter.com/2/problems/disallowed-resource'
}
/**
    * @export
    * @enum {string}
    */
export enum DisallowedResourceProblemResourceTypeEnum {
    Tweet = 'tweet',
    Media = 'media'
}
/**
    * @export
    * @enum {string}
    */
export enum DisallowedResourceProblemSectionEnum {
    Data = 'data',
    Includes = 'includes'
}

/**
 *
 * @export
 * @interface DisallowedResourceProblemAllOf
 */
export interface DisallowedResourceProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblemAllOf
     */
    type?: DisallowedResourceProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblemAllOf
     */
    resource_id: string;
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblemAllOf
     */
    resource_type: DisallowedResourceProblemAllOfResourceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof DisallowedResourceProblemAllOf
     */
    section: DisallowedResourceProblemAllOfSectionEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DisallowedResourceProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsDisallowedResource = 'https://api.twitter.com/2/problems/disallowed-resource'
}
/**
    * @export
    * @enum {string}
    */
export enum DisallowedResourceProblemAllOfResourceTypeEnum {
    Tweet = 'tweet',
    Media = 'media'
}
/**
    * @export
    * @enum {string}
    */
export enum DisallowedResourceProblemAllOfSectionEnum {
    Data = 'data',
    Includes = 'includes'
}

/**
 * The rule you have submitted is a duplicate.
 * @export
 * @interface DuplicateRuleProblem
 */
export interface DuplicateRuleProblem {
    /**
     *
     * @type {string}
     * @memberof DuplicateRuleProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof DuplicateRuleProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof DuplicateRuleProblem
     */
    type?: DuplicateRuleProblemTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DuplicateRuleProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsDuplicateRules = 'https://api.twitter.com/2/problems/duplicate-rules'
}

/**
 *
 * @export
 * @interface DuplicateRuleProblemAllOf
 */
export interface DuplicateRuleProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof DuplicateRuleProblemAllOf
     */
    type?: DuplicateRuleProblemAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum DuplicateRuleProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsDuplicateRules = 'https://api.twitter.com/2/problems/duplicate-rules'
}

/**
 * Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
 * @export
 * @interface EntityIndicesInclusiveExclusive
 */
export interface EntityIndicesInclusiveExclusive {
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof EntityIndicesInclusiveExclusive
     */
    start: number;
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof EntityIndicesInclusiveExclusive
     */
    end: number;
}
/**
 * Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive.
 * @export
 * @interface EntityIndicesInclusiveInclusive
 */
export interface EntityIndicesInclusiveInclusive {
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof EntityIndicesInclusiveInclusive
     */
    start: number;
    /**
     * Index (zero-based) at which position this entity ends.  The index is inclusive.
     * @type {number}
     * @memberof EntityIndicesInclusiveInclusive
     */
    end: number;
}
/**
 *
 * @export
 * @interface Expansions
 */
export interface Expansions {
    /**
     *
     * @type {Array<User>}
     * @memberof Expansions
     */
    users?: Array<User>;
    /**
     *
     * @type {Array<Tweet>}
     * @memberof Expansions
     */
    tweets?: Array<Tweet>;
    /**
     *
     * @type {Array<Place>}
     * @memberof Expansions
     */
    places?: Array<Place>;
    /**
     *
     * @type {Array<Media>}
     * @memberof Expansions
     */
    media?: Array<Media>;
    /**
     *
     * @type {Array<Poll>}
     * @memberof Expansions
     */
    polls?: Array<Poll>;
}
/**
 * A problem that indicates that you are not allowed to see a particular field on a Tweet, User, etc.
 * @export
 * @interface FieldUnauthorizedProblem
 */
export interface FieldUnauthorizedProblem {
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    type?: FieldUnauthorizedProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    section: FieldUnauthorizedProblemSectionEnum;
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    resource_type: FieldUnauthorizedProblemResourceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    field: string;
}

/**
    * @export
    * @enum {string}
    */
export enum FieldUnauthorizedProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsNotAuthorizedForField = 'https://api.twitter.com/2/problems/not-authorized-for-field'
}
/**
    * @export
    * @enum {string}
    */
export enum FieldUnauthorizedProblemSectionEnum {
    Data = 'data',
    Includes = 'includes'
}
/**
    * @export
    * @enum {string}
    */
export enum FieldUnauthorizedProblemResourceTypeEnum {
    Tweet = 'tweet',
    Media = 'media'
}

/**
 *
 * @export
 * @interface FieldUnauthorizedProblemAllOf
 */
export interface FieldUnauthorizedProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblemAllOf
     */
    type?: FieldUnauthorizedProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblemAllOf
     */
    section: FieldUnauthorizedProblemAllOfSectionEnum;
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblemAllOf
     */
    resource_type: FieldUnauthorizedProblemAllOfResourceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof FieldUnauthorizedProblemAllOf
     */
    field: string;
}

/**
    * @export
    * @enum {string}
    */
export enum FieldUnauthorizedProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsNotAuthorizedForField = 'https://api.twitter.com/2/problems/not-authorized-for-field'
}
/**
    * @export
    * @enum {string}
    */
export enum FieldUnauthorizedProblemAllOfSectionEnum {
    Data = 'data',
    Includes = 'includes'
}
/**
    * @export
    * @enum {string}
    */
export enum FieldUnauthorizedProblemAllOfResourceTypeEnum {
    Tweet = 'tweet',
    Media = 'media'
}

/**
 * @type FilteredStreamingTweet
 * A tweet or error that can be returned by the streaming tweet API
 * @export
 */
export type FilteredStreamingTweet = FilteredStreamingTweetOneOf | StreamingTweetOneOf;

/**
 * The values returned with a successful streamed tweet. Includes the user provided rules that the tweet matched.
 * @export
 * @interface FilteredStreamingTweetOneOf
 */
export interface FilteredStreamingTweetOneOf {
    /**
     *
     * @type {Tweet}
     * @memberof FilteredStreamingTweetOneOf
     */
    data: Tweet;
    /**
     * The list of rules which matched the tweet
     * @type {Array<FilteredStreamingTweetOneOfMatchingRules>}
     * @memberof FilteredStreamingTweetOneOf
     */
    matching_rules: Array<FilteredStreamingTweetOneOfMatchingRules>;
    /**
     *
     * @type {Expansions}
     * @memberof FilteredStreamingTweetOneOf
     */
    includes?: Expansions;
}
/**
 *
 * @export
 * @interface FilteredStreamingTweetOneOfMatchingRules
 */
export interface FilteredStreamingTweetOneOfMatchingRules {
    /**
     * Unique identifier of this rule.
     * @type {string}
     * @memberof FilteredStreamingTweetOneOfMatchingRules
     */
    id: string;
    /**
     * The user-supplied tag assigned to the rule which matched
     * @type {string}
     * @memberof FilteredStreamingTweetOneOfMatchingRules
     */
    tag?: string;
}
/**
 *
 * @export
 * @interface FullTextEntities
 */
export interface FullTextEntities {
    /**
     *
     * @type {Array<UrlEntity>}
     * @memberof FullTextEntities
     */
    urls?: Array<UrlEntity>;
    /**
     *
     * @type {Array<HashtagEntity>}
     * @memberof FullTextEntities
     */
    hashtags?: Array<HashtagEntity>;
    /**
     *
     * @type {Array<MentionEntity>}
     * @memberof FullTextEntities
     */
    mentions?: Array<MentionEntity>;
    /**
     *
     * @type {Array<CashtagEntity>}
     * @memberof FullTextEntities
     */
    cashtags?: Array<CashtagEntity>;
}
/**
 *
 * @export
 * @interface GenericMultipleUsersLookupResponse
 */
export interface GenericMultipleUsersLookupResponse {
    /**
     *
     * @type {Array<User>}
     * @memberof GenericMultipleUsersLookupResponse
     */
    data?: Array<User>;
    /**
     *
     * @type {Expansions}
     * @memberof GenericMultipleUsersLookupResponse
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof GenericMultipleUsersLookupResponse
     */
    errors?: Array<Problem>;
    /**
     *
     * @type {GenericMultipleUsersLookupResponseMeta}
     * @memberof GenericMultipleUsersLookupResponse
     */
    meta?: GenericMultipleUsersLookupResponseMeta;
}
/**
 *
 * @export
 * @interface GenericMultipleUsersLookupResponseMeta
 */
export interface GenericMultipleUsersLookupResponseMeta {
    /**
     * The previous token
     * @type {string}
     * @memberof GenericMultipleUsersLookupResponseMeta
     */
    previous_token?: string;
    /**
     * The next token
     * @type {string}
     * @memberof GenericMultipleUsersLookupResponseMeta
     */
    next_token?: string;
    /**
     * The number of user results returned in this response
     * @type {number}
     * @memberof GenericMultipleUsersLookupResponseMeta
     */
    result_count?: number;
}
/**
 * A generic problem with no additional information beyond that provided by the HTTP status code.
 * @export
 * @interface GenericProblem
 */
export interface GenericProblem {
    /**
     *
     * @type {string}
     * @memberof GenericProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof GenericProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof GenericProblem
     */
    type?: GenericProblemTypeEnum;
    /**
     *
     * @type {number}
     * @memberof GenericProblem
     */
    status: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GenericProblemTypeEnum {
    Aboutblank = 'about:blank'
}

/**
 *
 * @export
 * @interface GenericProblemAllOf
 */
export interface GenericProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof GenericProblemAllOf
     */
    type?: GenericProblemAllOfTypeEnum;
    /**
     *
     * @type {number}
     * @memberof GenericProblemAllOf
     */
    status: number;
}

/**
    * @export
    * @enum {string}
    */
export enum GenericProblemAllOfTypeEnum {
    Aboutblank = 'about:blank'
}

/**
 *
 * @export
 * @interface GenericTweetsTimelineResponse
 */
export interface GenericTweetsTimelineResponse {
    /**
     *
     * @type {Array<Tweet>}
     * @memberof GenericTweetsTimelineResponse
     */
    data?: Array<Tweet>;
    /**
     *
     * @type {Expansions}
     * @memberof GenericTweetsTimelineResponse
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof GenericTweetsTimelineResponse
     */
    errors?: Array<Problem>;
    /**
     *
     * @type {GenericTweetsTimelineResponseMeta}
     * @memberof GenericTweetsTimelineResponse
     */
    meta?: GenericTweetsTimelineResponseMeta;
}
/**
 *
 * @export
 * @interface GenericTweetsTimelineResponseMeta
 */
export interface GenericTweetsTimelineResponseMeta {
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof GenericTweetsTimelineResponseMeta
     */
    newest_id?: string;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof GenericTweetsTimelineResponseMeta
     */
    oldest_id?: string;
    /**
     * The previous token
     * @type {string}
     * @memberof GenericTweetsTimelineResponseMeta
     */
    previous_token?: string;
    /**
     * The next token
     * @type {string}
     * @memberof GenericTweetsTimelineResponseMeta
     */
    next_token?: string;
    /**
     * Number of Tweets in result set
     * @type {number}
     * @memberof GenericTweetsTimelineResponseMeta
     */
    result_count?: number;
}
/**
 *
 * @export
 * @interface Geo
 */
export interface Geo {
    /**
     *
     * @type {string}
     * @memberof Geo
     */
    type: GeoTypeEnum;
    /**
     *
     * @type {Array<number>}
     * @memberof Geo
     */
    bbox: Array<number>;
    /**
     *
     * @type {Point}
     * @memberof Geo
     */
    geometry?: Point;
    /**
     *
     * @type {object}
     * @memberof Geo
     */
    properties: object;
}

/**
    * @export
    * @enum {string}
    */
export enum GeoTypeEnum {
    Feature = 'Feature'
}

/**
 *
 * @export
 * @enum {string}
 */

export enum Granularity {
    Minute = 'minute',
    Hour = 'hour',
    Day = 'day'
}

/**
 *
 * @export
 * @interface HashtagEntity
 */
export interface HashtagEntity {
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof HashtagEntity
     */
    start: number;
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof HashtagEntity
     */
    end: number;
    /**
     * The text of the Hashtag
     * @type {string}
     * @memberof HashtagEntity
     */
    tag: string;
}
/**
 * Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
 * @export
 * @interface HashtagFields
 */
export interface HashtagFields {
    /**
     * The text of the Hashtag
     * @type {string}
     * @memberof HashtagFields
     */
    tag: string;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     *
     * @type {string}
     * @memberof InlineObject
     */
    target_user_id: string;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     *
     * @type {string}
     * @memberof InlineObject1
     */
    target_user_id: string;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     *
     * @type {string}
     * @memberof InlineObject2
     */
    target_user_id: string;
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     *
     * @type {boolean}
     * @memberof InlineObject3
     */
    hidden?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {InlineObject3}
     * @memberof InlineResponse200
     */
    data?: InlineObject3;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     *
     * @type {Array<Rule>}
     * @memberof InlineResponse2001
     */
    data: Array<Rule>;
    /**
     *
     * @type {RulesResponseMetadata}
     * @memberof InlineResponse2001
     */
    meta: RulesResponseMetadata;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     *
     * @type {Array<Tweet>}
     * @memberof InlineResponse2002
     */
    data?: Array<Tweet>;
    /**
     *
     * @type {Expansions}
     * @memberof InlineResponse2002
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof InlineResponse2002
     */
    errors?: Array<Problem>;
    /**
     *
     * @type {InlineResponse2002Meta}
     * @memberof InlineResponse2002
     */
    meta?: InlineResponse2002Meta;
}
/**
 *
 * @export
 * @interface InlineResponse2002Meta
 */
export interface InlineResponse2002Meta {
    /**
     * The previous token
     * @type {string}
     * @memberof InlineResponse2002Meta
     */
    previous_token?: string;
    /**
     * The next token
     * @type {string}
     * @memberof InlineResponse2002Meta
     */
    next_token?: string;
    /**
     * Number of Tweets in result set
     * @type {number}
     * @memberof InlineResponse2002Meta
     */
    result_count?: number;
}
/**
 * A problem that indicates this request is invalid.
 * @export
 * @interface InvalidRequestProblem
 */
export interface InvalidRequestProblem {
    /**
     *
     * @type {string}
     * @memberof InvalidRequestProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof InvalidRequestProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof InvalidRequestProblem
     */
    type?: InvalidRequestProblemTypeEnum;
    /**
     *
     * @type {Array<InvalidRequestProblemAllOfErrors>}
     * @memberof InvalidRequestProblem
     */
    errors?: Array<InvalidRequestProblemAllOfErrors>;
}

/**
    * @export
    * @enum {string}
    */
export enum InvalidRequestProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsInvalidRequest = 'https://api.twitter.com/2/problems/invalid-request'
}

/**
 *
 * @export
 * @interface InvalidRequestProblemAllOf
 */
export interface InvalidRequestProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof InvalidRequestProblemAllOf
     */
    type?: InvalidRequestProblemAllOfTypeEnum;
    /**
     *
     * @type {Array<InvalidRequestProblemAllOfErrors>}
     * @memberof InvalidRequestProblemAllOf
     */
    errors?: Array<InvalidRequestProblemAllOfErrors>;
}

/**
    * @export
    * @enum {string}
    */
export enum InvalidRequestProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsInvalidRequest = 'https://api.twitter.com/2/problems/invalid-request'
}

/**
 *
 * @export
 * @interface InvalidRequestProblemAllOfErrors
 */
export interface InvalidRequestProblemAllOfErrors {
    /**
     *
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InvalidRequestProblemAllOfErrors
     */
    parameters?: { [key: string]: Array<string>; };
    /**
     *
     * @type {string}
     * @memberof InvalidRequestProblemAllOfErrors
     */
    message?: string;
}
/**
 * The rule you have submitted is invalid.
 * @export
 * @interface InvalidRuleProblem
 */
export interface InvalidRuleProblem {
    /**
     *
     * @type {string}
     * @memberof InvalidRuleProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof InvalidRuleProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof InvalidRuleProblem
     */
    type?: InvalidRuleProblemTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InvalidRuleProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsInvalidRules = 'https://api.twitter.com/2/problems/invalid-rules'
}

/**
 *
 * @export
 * @interface InvalidRuleProblemAllOf
 */
export interface InvalidRuleProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof InvalidRuleProblemAllOf
     */
    type?: InvalidRuleProblemAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InvalidRuleProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsInvalidRules = 'https://api.twitter.com/2/problems/invalid-rules'
}

/**
 * Represent a List
 * @export
 * @interface List
 */
export interface List {
    /**
     * Unique identifier of this list.
     * @type {string}
     * @memberof List
     */
    id: string;
    /**
     * The name of this list.
     * @type {string}
     * @memberof List
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof List
     */
    created_at?: string;
    /**
     *
     * @type {number}
     * @memberof List
     */
    follower_count?: number;
    /**
     *
     * @type {number}
     * @memberof List
     */
    member_count?: number;
    /**
     *
     * @type {string}
     * @memberof List
     */
    visibility?: ListVisibilityEnum;
    /**
     *
     * @type {string}
     * @memberof List
     */
    description?: string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof List
     */
    owner_id?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListVisibilityEnum {
    Public = 'Public',
    Private = 'Private'
}

/**
 * @type Media
 * @export
 */
export type Media = AnimatedGif | Photo | Video;

/**
 *
 * @export
 * @interface MentionEntity
 */
export interface MentionEntity {
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof MentionEntity
     */
    start: number;
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof MentionEntity
     */
    end: number;
    /**
     * The Twitter handle (screen name) of this user.
     * @type {string}
     * @memberof MentionEntity
     */
    username: string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof MentionEntity
     */
    id: string;
}
/**
 * Represent the portion of text recognized as a User mention, and its start and end position within the text.
 * @export
 * @interface MentionFields
 */
export interface MentionFields {
    /**
     * The Twitter handle (screen name) of this user.
     * @type {string}
     * @memberof MentionFields
     */
    username: string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof MentionFields
     */
    id: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {number}
     * @memberof ModelError
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    message: string;
}
/**
 *
 * @export
 * @interface MultiTweetLookupResponse
 */
export interface MultiTweetLookupResponse {
    /**
     *
     * @type {Array<Tweet>}
     * @memberof MultiTweetLookupResponse
     */
    data?: Array<Tweet>;
    /**
     *
     * @type {Expansions}
     * @memberof MultiTweetLookupResponse
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof MultiTweetLookupResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface MultiUserLookupResponse
 */
export interface MultiUserLookupResponse {
    /**
     *
     * @type {Array<User>}
     * @memberof MultiUserLookupResponse
     */
    data?: Array<User>;
    /**
     *
     * @type {Expansions}
     * @memberof MultiUserLookupResponse
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof MultiUserLookupResponse
     */
    errors?: Array<Problem>;
}
/**
 * You have been disconnected for operational reasons.
 * @export
 * @interface OperationalDisconnectProblem
 */
export interface OperationalDisconnectProblem {
    /**
     *
     * @type {string}
     * @memberof OperationalDisconnectProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof OperationalDisconnectProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof OperationalDisconnectProblem
     */
    type?: OperationalDisconnectProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof OperationalDisconnectProblem
     */
    disconnect_type?: OperationalDisconnectProblemDisconnectTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OperationalDisconnectProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsOperationalDisconnect = 'https://api.twitter.com/2/problems/operational-disconnect'
}
/**
    * @export
    * @enum {string}
    */
export enum OperationalDisconnectProblemDisconnectTypeEnum {
    OperationalDisconnect = 'OperationalDisconnect',
    UpstreamOperationalDisconnect = 'UpstreamOperationalDisconnect',
    ForceDisconnect = 'ForceDisconnect',
    UpstreamUncleanDisconnect = 'UpstreamUncleanDisconnect',
    SlowReader = 'SlowReader',
    InternalError = 'InternalError',
    PackageUpgraded = 'PackageUpgraded',
    PackageDowngraded = 'PackageDowngraded',
    ClientApplicationStateDegraded = 'ClientApplicationStateDegraded'
}

/**
 *
 * @export
 * @interface OperationalDisconnectProblemAllOf
 */
export interface OperationalDisconnectProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof OperationalDisconnectProblemAllOf
     */
    type?: OperationalDisconnectProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof OperationalDisconnectProblemAllOf
     */
    disconnect_type?: OperationalDisconnectProblemAllOfDisconnectTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OperationalDisconnectProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsOperationalDisconnect = 'https://api.twitter.com/2/problems/operational-disconnect'
}
/**
    * @export
    * @enum {string}
    */
export enum OperationalDisconnectProblemAllOfDisconnectTypeEnum {
    OperationalDisconnect = 'OperationalDisconnect',
    UpstreamOperationalDisconnect = 'UpstreamOperationalDisconnect',
    ForceDisconnect = 'ForceDisconnect',
    UpstreamUncleanDisconnect = 'UpstreamUncleanDisconnect',
    SlowReader = 'SlowReader',
    InternalError = 'InternalError',
    PackageUpgraded = 'PackageUpgraded',
    PackageDowngraded = 'PackageDowngraded',
    ClientApplicationStateDegraded = 'ClientApplicationStateDegraded'
}

/**
 *
 * @export
 * @interface Photo
 */
export interface Photo {
    /**
     * The Media Key identifier for this attachment.
     * @type {string}
     * @memberof Photo
     */
    media_key?: string;
    /**
     * The height of the media in pixels
     * @type {number}
     * @memberof Photo
     */
    height?: number;
    /**
     * The width of the media in pixels
     * @type {number}
     * @memberof Photo
     */
    width?: number;
    /**
     *
     * @type {string}
     * @memberof Photo
     */
    type?: PhotoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof Photo
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PhotoTypeEnum {
    Photo = 'photo'
}

/**
 *
 * @export
 * @interface PhotoAllOf
 */
export interface PhotoAllOf {
    /**
     *
     * @type {string}
     * @memberof PhotoAllOf
     */
    type?: PhotoAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof PhotoAllOf
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PhotoAllOfTypeEnum {
    Photo = 'photo'
}

/**
 *
 * @export
 * @interface Place
 */
export interface Place {
    /**
     * The identifier for this place
     * @type {string}
     * @memberof Place
     */
    id: string;
    /**
     * The human readable name of this place.
     * @type {string}
     * @memberof Place
     */
    name?: string;
    /**
     * A two-letter ISO 3166-1 alpha-2 country code
     * @type {string}
     * @memberof Place
     */
    country_code?: string;
    /**
     *
     * @type {PlaceType}
     * @memberof Place
     */
    place_type?: PlaceType;
    /**
     * The full name of this place.
     * @type {string}
     * @memberof Place
     */
    full_name: string;
    /**
     * The full name of the county in which this place exists.
     * @type {string}
     * @memberof Place
     */
    country?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Place
     */
    contained_within?: Array<string>;
    /**
     *
     * @type {Geo}
     * @memberof Place
     */
    geo?: Geo;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum PlaceType {
    Poi = 'poi',
    Neighborhood = 'neighborhood',
    City = 'city',
    Admin = 'admin',
    Country = 'country',
    Unknown = 'unknown'
}

/**
 * A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
 * @export
 * @interface Point
 */
export interface Point {
    /**
     *
     * @type {string}
     * @memberof Point
     */
    type: PointTypeEnum;
    /**
     * A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`.
     * @type {Array<number>}
     * @memberof Point
     */
    coordinates: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum PointTypeEnum {
    Point = 'Point'
}

/**
 * Represent a Poll attached to a Tweet
 * @export
 * @interface Poll
 */
export interface Poll {
    /**
     * Unique identifier of this poll.
     * @type {string}
     * @memberof Poll
     */
    id: string;
    /**
     *
     * @type {Array<PollOption>}
     * @memberof Poll
     */
    options: Array<PollOption>;
    /**
     *
     * @type {string}
     * @memberof Poll
     */
    voting_status?: PollVotingStatusEnum;
    /**
     *
     * @type {string}
     * @memberof Poll
     */
    end_datetime?: string;
    /**
     *
     * @type {number}
     * @memberof Poll
     */
    duration_minutes?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PollVotingStatusEnum {
    Open = 'open',
    Closed = 'closed'
}

/**
 * Describes a choice in a Poll object.
 * @export
 * @interface PollOption
 */
export interface PollOption {
    /**
     * Position of this choice in the poll.
     * @type {number}
     * @memberof PollOption
     */
    position: number;
    /**
     * The text of a poll choice.
     * @type {string}
     * @memberof PollOption
     */
    label: string;
    /**
     * Number of users who voted for this choice.
     * @type {number}
     * @memberof PollOption
     */
    votes: number;
}
/**
 * @type Problem
 * An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
 * @export
 */
export type Problem = ClientDisconnectedProblem | ClientForbiddenProblem | ConnectionExceptionProblem | DisallowedResourceProblem | DuplicateRuleProblem | FieldUnauthorizedProblem | GenericProblem | InvalidRequestProblem | InvalidRuleProblem | OperationalDisconnectProblem | ResourceNotFoundProblem | ResourceUnauthorizedProblem | ResourceUnavailableProblem | RulesCapProblem | UnsupportedAuthenticationProblem | UsageCapExceededProblem;

/**
 *
 * @export
 * @interface ProblemFields
 */
export interface ProblemFields {
    /**
     *
     * @type {string}
     * @memberof ProblemFields
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof ProblemFields
     */
    detail: string;
}
/**
 * Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
 * @export
 * @enum {string}
 */

export enum ReplySettings {
    Everyone = 'everyone',
    MentionedUsers = 'mentionedUsers',
    Following = 'following',
    Other = 'other'
}

/**
 * A problem that indicates that a given Tweet, User, etc. does not exist.
 * @export
 * @interface ResourceNotFoundProblem
 */
export interface ResourceNotFoundProblem {
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    type?: ResourceNotFoundProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    parameter: string;
    /**
     * Value will match the schema of the field.
     * @type {any}
     * @memberof ResourceNotFoundProblem
     */
    value: any | null;
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    resource_id: string;
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    resource_type: ResourceNotFoundProblemResourceTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceNotFoundProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsResourceNotFound = 'https://api.twitter.com/2/problems/resource-not-found'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceNotFoundProblemResourceTypeEnum {
    User = 'user',
    Tweet = 'tweet',
    Media = 'media'
}

/**
 *
 * @export
 * @interface ResourceNotFoundProblemAllOf
 */
export interface ResourceNotFoundProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblemAllOf
     */
    type?: ResourceNotFoundProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblemAllOf
     */
    parameter: string;
    /**
     * Value will match the schema of the field.
     * @type {any}
     * @memberof ResourceNotFoundProblemAllOf
     */
    value: any | null;
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblemAllOf
     */
    resource_id: string;
    /**
     *
     * @type {string}
     * @memberof ResourceNotFoundProblemAllOf
     */
    resource_type: ResourceNotFoundProblemAllOfResourceTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceNotFoundProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsResourceNotFound = 'https://api.twitter.com/2/problems/resource-not-found'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceNotFoundProblemAllOfResourceTypeEnum {
    User = 'user',
    Tweet = 'tweet',
    Media = 'media'
}

/**
 * A problem that indicates you are not allowed to see a particular Tweet, User, etc.
 * @export
 * @interface ResourceUnauthorizedProblem
 */
export interface ResourceUnauthorizedProblem {
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    type?: ResourceUnauthorizedProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    parameter: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    section: ResourceUnauthorizedProblemSectionEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    resource_id: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    resource_type: ResourceUnauthorizedProblemResourceTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceUnauthorizedProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsNotAuthorizedForResource = 'https://api.twitter.com/2/problems/not-authorized-for-resource'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceUnauthorizedProblemSectionEnum {
    Data = 'data',
    Includes = 'includes'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceUnauthorizedProblemResourceTypeEnum {
    Tweet = 'tweet',
    User = 'user',
    Media = 'media'
}

/**
 *
 * @export
 * @interface ResourceUnauthorizedProblemAllOf
 */
export interface ResourceUnauthorizedProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    type?: ResourceUnauthorizedProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    parameter: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    section: ResourceUnauthorizedProblemAllOfSectionEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    resource_id: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    resource_type: ResourceUnauthorizedProblemAllOfResourceTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceUnauthorizedProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsNotAuthorizedForResource = 'https://api.twitter.com/2/problems/not-authorized-for-resource'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceUnauthorizedProblemAllOfSectionEnum {
    Data = 'data',
    Includes = 'includes'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceUnauthorizedProblemAllOfResourceTypeEnum {
    Tweet = 'tweet',
    User = 'user',
    Media = 'media'
}

/**
 * A problem that indicates a particular Tweet, User, etc. is not available to you.
 * @export
 * @interface ResourceUnavailableProblem
 */
export interface ResourceUnavailableProblem {
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    type?: ResourceUnavailableProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    parameter: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    resource_id: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    resource_type: ResourceUnavailableProblemResourceTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceUnavailableProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsResourceUnavailable = 'https://api.twitter.com/2/problems/resource-unavailable'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceUnavailableProblemResourceTypeEnum {
    User = 'user',
    Tweet = 'tweet',
    Media = 'media'
}

/**
 *
 * @export
 * @interface ResourceUnavailableProblemAllOf
 */
export interface ResourceUnavailableProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblemAllOf
     */
    type?: ResourceUnavailableProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblemAllOf
     */
    parameter: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblemAllOf
     */
    resource_id: string;
    /**
     *
     * @type {string}
     * @memberof ResourceUnavailableProblemAllOf
     */
    resource_type: ResourceUnavailableProblemAllOfResourceTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceUnavailableProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsResourceUnavailable = 'https://api.twitter.com/2/problems/resource-unavailable'
}
/**
    * @export
    * @enum {string}
    */
export enum ResourceUnavailableProblemAllOfResourceTypeEnum {
    User = 'user',
    Tweet = 'tweet',
    Media = 'media'
}

/**
 * A user-provided stream filtering rule.
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * The filterlang value of the rule.
     * @type {string}
     * @memberof Rule
     */
    value: string;
    /**
     * A tag meant for the labeling of user provided rules.
     * @type {string}
     * @memberof Rule
     */
    tag?: string;
    /**
     * Unique identifier of this rule.
     * @type {string}
     * @memberof Rule
     */
    id?: string;
}
/**
 * A user-provided stream filtering rule.
 * @export
 * @interface RuleNoId
 */
export interface RuleNoId {
    /**
     * The filterlang value of the rule.
     * @type {string}
     * @memberof RuleNoId
     */
    value: string;
    /**
     * A tag meant for the labeling of user provided rules.
     * @type {string}
     * @memberof RuleNoId
     */
    tag?: string;
}
/**
 * You have exceeded the maximum number of rules.
 * @export
 * @interface RulesCapProblem
 */
export interface RulesCapProblem {
    /**
     *
     * @type {string}
     * @memberof RulesCapProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof RulesCapProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof RulesCapProblem
     */
    type?: RulesCapProblemTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RulesCapProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsRuleCap = 'https://api.twitter.com/2/problems/rule-cap'
}

/**
 *
 * @export
 * @interface RulesCapProblemAllOf
 */
export interface RulesCapProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof RulesCapProblemAllOf
     */
    type?: RulesCapProblemAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RulesCapProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsRuleCap = 'https://api.twitter.com/2/problems/rule-cap'
}

/**
 * @type RulesRequestSummary
 * @export
 */
export type RulesRequestSummary = RulesRequestSummaryOneOf | RulesRequestSummaryOneOf1;

/**
 * A summary of the results of the addition of user-specified stream filtering rules.
 * @export
 * @interface RulesRequestSummaryOneOf
 */
export interface RulesRequestSummaryOneOf {
    /**
     * Number of user-specified stream filtering rules that were created.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf
     */
    created: number;
    /**
     * Number of user-specified stream filtering rules that were not created.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf
     */
    not_created: number;
    /**
     * Number of valid user-specified stream filtering rules.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf
     */
    valid: number;
    /**
     * Number of invalid user-specified stream filtering rules.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf
     */
    invalid: number;
}
/**
 *
 * @export
 * @interface RulesRequestSummaryOneOf1
 */
export interface RulesRequestSummaryOneOf1 {
    /**
     * Number of user-specified stream filtering rules that were deleted.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf1
     */
    deleted: number;
    /**
     * Number of user-specified stream filtering rules that were not deleted.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf1
     */
    not_deleted: number;
}
/**
 *
 * @export
 * @interface RulesResponseMetadata
 */
export interface RulesResponseMetadata {
    /**
     *
     * @type {string}
     * @memberof RulesResponseMetadata
     */
    sent: string;
    /**
     *
     * @type {RulesRequestSummary}
     * @memberof RulesResponseMetadata
     */
    summary?: RulesRequestSummary;
}
/**
 * Represent a Search Count Result
 * @export
 * @interface SearchCount
 */
export interface SearchCount {
    /**
     * The end time of the bucket
     * @type {string}
     * @memberof SearchCount
     */
    end: string;
    /**
     * The start time of the bucket
     * @type {string}
     * @memberof SearchCount
     */
    start: string;
    /**
     * The count for the bucket
     * @type {number}
     * @memberof SearchCount
     */
    tweet_count: number;
}
/**
 *
 * @export
 * @interface SingleTweetLookupResponse
 */
export interface SingleTweetLookupResponse {
    /**
     *
     * @type {Tweet}
     * @memberof SingleTweetLookupResponse
     */
    data?: Tweet;
    /**
     *
     * @type {Expansions}
     * @memberof SingleTweetLookupResponse
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof SingleTweetLookupResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface SingleUserLookupResponse
 */
export interface SingleUserLookupResponse {
    /**
     *
     * @type {User}
     * @memberof SingleUserLookupResponse
     */
    data?: User;
    /**
     *
     * @type {Expansions}
     * @memberof SingleUserLookupResponse
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof SingleUserLookupResponse
     */
    errors?: Array<Problem>;
}
/**
 * @type StreamingTweet
 * A tweet or error that can be returned by the streaming tweet API.
 * @export
 */
export type StreamingTweet = SingleTweetLookupResponse | StreamingTweetOneOf;

/**
 *
 * @export
 * @interface StreamingTweetOneOf
 */
export interface StreamingTweetOneOf {
    /**
     *
     * @type {Array<Problem>}
     * @memberof StreamingTweetOneOf
     */
    errors: Array<Problem>;
}
/**
 *
 * @export
 * @interface Tweet
 */
export interface Tweet {
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    id: string;
    /**
     * Creation time of the Tweet.
     * @type {string}
     * @memberof Tweet
     */
    created_at?: string;
    /**
     * The content of the Tweet.
     * @type {string}
     * @memberof Tweet
     */
    text: string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    author_id?: string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    in_reply_to_user_id?: string;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    conversation_id?: string;
    /**
     *
     * @type {ReplySettings}
     * @memberof Tweet
     */
    reply_settings?: ReplySettings;
    /**
     * A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent.
     * @type {Array<TweetReferencedTweets>}
     * @memberof Tweet
     */
    referenced_tweets?: Array<TweetReferencedTweets>;
    /**
     *
     * @type {TweetAttachments}
     * @memberof Tweet
     */
    attachments?: TweetAttachments;
    /**
     *
     * @type {Array<ContextAnnotation>}
     * @memberof Tweet
     */
    context_annotations?: Array<ContextAnnotation>;
    /**
     *
     * @type {TweetWithheld}
     * @memberof Tweet
     */
    withheld?: TweetWithheld;
    /**
     *
     * @type {TweetGeo}
     * @memberof Tweet
     */
    geo?: TweetGeo;
    /**
     *
     * @type {FullTextEntities}
     * @memberof Tweet
     */
    entities?: FullTextEntities;
    /**
     *
     * @type {TweetPublicMetrics}
     * @memberof Tweet
     */
    public_metrics?: TweetPublicMetrics;
    /**
     * Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences.
     * @type {boolean}
     * @memberof Tweet
     */
    possibly_sensitive?: boolean;
    /**
     * Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag.
     * @type {string}
     * @memberof Tweet
     */
    lang?: string;
    /**
     * The name of the app the user Tweeted from.
     * @type {string}
     * @memberof Tweet
     */
    source?: string;
    /**
     *
     * @type {TweetNonPublicMetrics}
     * @memberof Tweet
     */
    non_public_metrics?: TweetNonPublicMetrics;
    /**
     *
     * @type {TweetPromotedMetrics}
     * @memberof Tweet
     */
    promoted_metrics?: TweetPromotedMetrics;
    /**
     *
     * @type {TweetOrganicMetrics}
     * @memberof Tweet
     */
    organic_metrics?: TweetOrganicMetrics;
}
/**
 * Specifies the type of attachments (if any) present in this Tweet.
 * @export
 * @interface TweetAttachments
 */
export interface TweetAttachments {
    /**
     * A list of Media Keys for each one of the media attachments (if media are attached).
     * @type {Array<string>}
     * @memberof TweetAttachments
     */
    media_keys?: Array<string>;
    /**
     * A list of poll IDs (if polls are attached).
     * @type {Array<string>}
     * @memberof TweetAttachments
     */
    poll_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface TweetCountsResponse
 */
export interface TweetCountsResponse {
    /**
     *
     * @type {Array<SearchCount>}
     * @memberof TweetCountsResponse
     */
    data?: Array<SearchCount>;
    /**
     *
     * @type {Array<Problem>}
     * @memberof TweetCountsResponse
     */
    errors?: Array<Problem>;
    /**
     *
     * @type {TweetCountsResponseMeta}
     * @memberof TweetCountsResponse
     */
    meta?: TweetCountsResponseMeta;
}
/**
 *
 * @export
 * @interface TweetCountsResponseMeta
 */
export interface TweetCountsResponseMeta {
    /**
     * This value is used to get the next \'page\' of results by providing it to the next_token parameter.
     * @type {string}
     * @memberof TweetCountsResponseMeta
     */
    next_token?: string;
    /**
     * Sum of search query count results
     * @type {number}
     * @memberof TweetCountsResponseMeta
     */
    total_tweet_count?: number;
}
/**
 * The location tagged on the Tweet, if the user provided one.
 * @export
 * @interface TweetGeo
 */
export interface TweetGeo {
    /**
     *
     * @type {Point}
     * @memberof TweetGeo
     */
    coordinates?: Point;
    /**
     * The identifier for this place
     * @type {string}
     * @memberof TweetGeo
     */
    place_id?: string;
}
/**
 * Nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetNonPublicMetrics
 */
export interface TweetNonPublicMetrics {
    /**
     * Number of times this Tweet has been viewed.
     * @type {number}
     * @memberof TweetNonPublicMetrics
     */
    impression_count?: number;
}
/**
 * Organic nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetOrganicMetrics
 */
export interface TweetOrganicMetrics {
    /**
     * Number of times this Tweet has been viewed.
     * @type {number}
     * @memberof TweetOrganicMetrics
     */
    impression_count: number;
    /**
     * Number of times this Tweet has been Retweeted.
     * @type {number}
     * @memberof TweetOrganicMetrics
     */
    retweet_count: number;
    /**
     * Number of times this Tweet has been replied to.
     * @type {number}
     * @memberof TweetOrganicMetrics
     */
    reply_count: number;
    /**
     * Number of times this Tweet has been liked.
     * @type {number}
     * @memberof TweetOrganicMetrics
     */
    like_count: number;
}
/**
 * Promoted nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetPromotedMetrics
 */
export interface TweetPromotedMetrics {
    /**
     * Number of times this Tweet has been viewed.
     * @type {number}
     * @memberof TweetPromotedMetrics
     */
    impression_count?: number;
    /**
     * Number of times this Tweet has been liked.
     * @type {number}
     * @memberof TweetPromotedMetrics
     */
    like_count?: number;
    /**
     * Number of times this Tweet has been replied to.
     * @type {number}
     * @memberof TweetPromotedMetrics
     */
    reply_count?: number;
    /**
     * Number of times this Tweet has been Retweeted.
     * @type {number}
     * @memberof TweetPromotedMetrics
     */
    retweet_count?: number;
}
/**
 * Engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetPublicMetrics
 */
export interface TweetPublicMetrics {
    /**
     * Number of times this Tweet has been Retweeted.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    retweet_count: number;
    /**
     * Number of times this Tweet has been replied to.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    reply_count: number;
    /**
     * Number of times this Tweet has been liked.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    like_count: number;
    /**
     * Number of times this Tweet has been quoted.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    quote_count?: number;
}
/**
 *
 * @export
 * @interface TweetReferencedTweets
 */
export interface TweetReferencedTweets {
    /**
     *
     * @type {string}
     * @memberof TweetReferencedTweets
     */
    type: TweetReferencedTweetsTypeEnum;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetReferencedTweets
     */
    id: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TweetReferencedTweetsTypeEnum {
    Retweeted = 'retweeted',
    Quoted = 'quoted',
    RepliedTo = 'replied_to'
}

/**
 *
 * @export
 * @interface TweetSearchResponse
 */
export interface TweetSearchResponse {
    /**
     *
     * @type {Array<Tweet>}
     * @memberof TweetSearchResponse
     */
    data?: Array<Tweet>;
    /**
     *
     * @type {Expansions}
     * @memberof TweetSearchResponse
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof TweetSearchResponse
     */
    errors?: Array<Problem>;
    /**
     *
     * @type {TweetSearchResponseMeta}
     * @memberof TweetSearchResponse
     */
    meta?: TweetSearchResponseMeta;
}
/**
 *
 * @export
 * @interface TweetSearchResponseMeta
 */
export interface TweetSearchResponseMeta {
    /**
     * Most recent Tweet Id returned by search query
     * @type {string}
     * @memberof TweetSearchResponseMeta
     */
    newest_id?: string;
    /**
     * Oldest Tweet Id returned by search query
     * @type {string}
     * @memberof TweetSearchResponseMeta
     */
    oldest_id?: string;
    /**
     * This value is used to get the next \'page\' of results by providing it to the next_token parameter.
     * @type {string}
     * @memberof TweetSearchResponseMeta
     */
    next_token?: string;
    /**
     * Number of search query results
     * @type {number}
     * @memberof TweetSearchResponseMeta
     */
    result_count?: number;
}
/**
 * Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
 * @export
 * @interface TweetWithheld
 */
export interface TweetWithheld {
    /**
     * Indicates if the content is being withheld for on the basis of copyright infringement.
     * @type {boolean}
     * @memberof TweetWithheld
     */
    copyright: boolean;
    /**
     * Provides a list of countries where this content is not available.
     * @type {Set<string>}
     * @memberof TweetWithheld
     */
    country_codes: Set<string>;
    /**
     * Indicates whether the content being withheld is the `tweet` or a `user`.
     * @type {string}
     * @memberof TweetWithheld
     */
    scope?: TweetWithheldScopeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TweetWithheldScopeEnum {
    Tweet = 'tweet',
    User = 'user'
}

/**
 * Represent the portion of text recognized as a URL.
 * @export
 * @interface URLFields
 */
export interface URLFields {
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof URLFields
     */
    url: string;
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof URLFields
     */
    expanded_url?: string;
    /**
     * The URL as displayed in the Twitter client.
     * @type {string}
     * @memberof URLFields
     */
    display_url?: string;
    /**
     * Fully resolved url
     * @type {string}
     * @memberof URLFields
     */
    unwound_url?: string;
    /**
     * HTTP Status Code.
     * @type {number}
     * @memberof URLFields
     */
    status?: number;
    /**
     * Title of the page the URL points to.
     * @type {string}
     * @memberof URLFields
     */
    title?: string;
    /**
     * Description of the URL landing page.
     * @type {string}
     * @memberof URLFields
     */
    description?: string;
    /**
     *
     * @type {Array<URLImage>}
     * @memberof URLFields
     */
    images?: Array<URLImage>;
}
/**
 * Represent the information for the URL image
 * @export
 * @interface URLImage
 */
export interface URLImage {
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof URLImage
     */
    url?: string;
    /**
     * The height of the media in pixels
     * @type {number}
     * @memberof URLImage
     */
    height?: number;
    /**
     * The width of the media in pixels
     * @type {number}
     * @memberof URLImage
     */
    width?: number;
}
/**
 * A problem that indicates that the authentication used is not supported.
 * @export
 * @interface UnsupportedAuthenticationProblem
 */
export interface UnsupportedAuthenticationProblem {
    /**
     *
     * @type {string}
     * @memberof UnsupportedAuthenticationProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof UnsupportedAuthenticationProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof UnsupportedAuthenticationProblem
     */
    type?: UnsupportedAuthenticationProblemTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UnsupportedAuthenticationProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsUnsupportedAuthentication = 'https://api.twitter.com/2/problems/unsupported-authentication'
}

/**
 *
 * @export
 * @interface UnsupportedAuthenticationProblemAllOf
 */
export interface UnsupportedAuthenticationProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof UnsupportedAuthenticationProblemAllOf
     */
    type?: UnsupportedAuthenticationProblemAllOfTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UnsupportedAuthenticationProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsUnsupportedAuthentication = 'https://api.twitter.com/2/problems/unsupported-authentication'
}

/**
 * Represent the portion of text recognized as a URL, and its start and end position within the text.
 * @export
 * @interface UrlEntity
 */
export interface UrlEntity {
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof UrlEntity
     */
    start: number;
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof UrlEntity
     */
    end: number;
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof UrlEntity
     */
    url: string;
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof UrlEntity
     */
    expanded_url?: string;
    /**
     * The URL as displayed in the Twitter client.
     * @type {string}
     * @memberof UrlEntity
     */
    display_url?: string;
    /**
     * Fully resolved url
     * @type {string}
     * @memberof UrlEntity
     */
    unwound_url?: string;
    /**
     * HTTP Status Code.
     * @type {number}
     * @memberof UrlEntity
     */
    status?: number;
    /**
     * Title of the page the URL points to.
     * @type {string}
     * @memberof UrlEntity
     */
    title?: string;
    /**
     * Description of the URL landing page.
     * @type {string}
     * @memberof UrlEntity
     */
    description?: string;
    /**
     *
     * @type {Array<URLImage>}
     * @memberof UrlEntity
     */
    images?: Array<URLImage>;
}
/**
 * A problem that indicates that a usage cap has been exceeded.
 * @export
 * @interface UsageCapExceededProblem
 */
export interface UsageCapExceededProblem {
    /**
     *
     * @type {string}
     * @memberof UsageCapExceededProblem
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof UsageCapExceededProblem
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof UsageCapExceededProblem
     */
    type?: UsageCapExceededProblemTypeEnum;
    /**
     *
     * @type {string}
     * @memberof UsageCapExceededProblem
     */
    period?: UsageCapExceededProblemPeriodEnum;
    /**
     *
     * @type {string}
     * @memberof UsageCapExceededProblem
     */
    scope?: UsageCapExceededProblemScopeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UsageCapExceededProblemTypeEnum {
    HttpsApiTwitterCom2ProblemsUsageCapped = 'https://api.twitter.com/2/problems/usage-capped'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCapExceededProblemPeriodEnum {
    Daily = 'Daily',
    Monthly = 'Monthly'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCapExceededProblemScopeEnum {
    Account = 'Account',
    Product = 'Product'
}

/**
 *
 * @export
 * @interface UsageCapExceededProblemAllOf
 */
export interface UsageCapExceededProblemAllOf {
    /**
     *
     * @type {string}
     * @memberof UsageCapExceededProblemAllOf
     */
    type?: UsageCapExceededProblemAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof UsageCapExceededProblemAllOf
     */
    period?: UsageCapExceededProblemAllOfPeriodEnum;
    /**
     *
     * @type {string}
     * @memberof UsageCapExceededProblemAllOf
     */
    scope?: UsageCapExceededProblemAllOfScopeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UsageCapExceededProblemAllOfTypeEnum {
    HttpsApiTwitterCom2ProblemsUsageCapped = 'https://api.twitter.com/2/problems/usage-capped'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCapExceededProblemAllOfPeriodEnum {
    Daily = 'Daily',
    Monthly = 'Monthly'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCapExceededProblemAllOfScopeEnum {
    Account = 'Account',
    Product = 'Product'
}

/**
 * The Twitter User object
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * Creation time of this user.
     * @type {string}
     * @memberof User
     */
    created_at?: string;
    /**
     * The friendly name of this user, as shown on their profile.
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * The Twitter handle (screen name) of this user.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * Indicates if this user has chosen to protect their Tweets (in other words, if this user\'s Tweets are private).
     * @type {boolean}
     * @memberof User
     */
    _protected?: boolean;
    /**
     * Indicate if this user is a verified Twitter User.
     * @type {boolean}
     * @memberof User
     */
    verified?: boolean;
    /**
     *
     * @type {UserWithheld}
     * @memberof User
     */
    withheld?: UserWithheld;
    /**
     * The URL to the profile image for this user.
     * @type {string}
     * @memberof User
     */
    profile_image_url?: string;
    /**
     * The location specified in the user\'s profile, if the user provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries.
     * @type {string}
     * @memberof User
     */
    location?: string;
    /**
     * The URL specified in the user\'s profile.
     * @type {string}
     * @memberof User
     */
    url?: string;
    /**
     * The text of this user\'s profile description (also known as bio), if the user provided one.
     * @type {string}
     * @memberof User
     */
    description?: string;
    /**
     *
     * @type {UserEntities}
     * @memberof User
     */
    entities?: UserEntities;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof User
     */
    pinned_tweet_id?: string;
    /**
     *
     * @type {UserPublicMetrics}
     * @memberof User
     */
    public_metrics?: UserPublicMetrics;
}
/**
 * A list of metadata found in the user\'s profile description.
 * @export
 * @interface UserEntities
 */
export interface UserEntities {
    /**
     *
     * @type {UserEntitiesUrl}
     * @memberof UserEntities
     */
    url?: UserEntitiesUrl;
    /**
     *
     * @type {FullTextEntities}
     * @memberof UserEntities
     */
    description?: FullTextEntities;
}
/**
 * Expanded details for the URL specified in the user\'s profile, with start and end indices.
 * @export
 * @interface UserEntitiesUrl
 */
export interface UserEntitiesUrl {
    /**
     *
     * @type {Array<UrlEntity>}
     * @memberof UserEntitiesUrl
     */
    urls?: Array<UrlEntity>;
}
/**
 * A list of metrics for this user
 * @export
 * @interface UserPublicMetrics
 */
export interface UserPublicMetrics {
    /**
     * Number of users who are following this user.
     * @type {number}
     * @memberof UserPublicMetrics
     */
    followers_count: number;
    /**
     * Number of users this user is following.
     * @type {number}
     * @memberof UserPublicMetrics
     */
    following_count: number;
    /**
     * The number of Tweets (including Retweets) posted by this user.
     * @type {number}
     * @memberof UserPublicMetrics
     */
    tweet_count: number;
    /**
     * The number of lists that include this user.
     * @type {number}
     * @memberof UserPublicMetrics
     */
    listed_count: number;
}
/**
 * Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
 * @export
 * @interface UserWithheld
 */
export interface UserWithheld {
    /**
     * Provides a list of countries where this content is not available.
     * @type {Set<string>}
     * @memberof UserWithheld
     */
    country_codes: Set<string>;
    /**
     * Indicates that the content being withheld is a `user`.
     * @type {string}
     * @memberof UserWithheld
     */
    scope?: UserWithheldScopeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserWithheldScopeEnum {
    User = 'user'
}

/**
 *
 * @export
 * @interface UsersBlockingMutationResponse
 */
export interface UsersBlockingMutationResponse {
    /**
     *
     * @type {UsersBlockingMutationResponseData}
     * @memberof UsersBlockingMutationResponse
     */
    data?: UsersBlockingMutationResponseData;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersBlockingMutationResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface UsersBlockingMutationResponseData
 */
export interface UsersBlockingMutationResponseData {
    /**
     *
     * @type {boolean}
     * @memberof UsersBlockingMutationResponseData
     */
    blocking?: boolean;
}
/**
 *
 * @export
 * @interface UsersFollowingCreateResponse
 */
export interface UsersFollowingCreateResponse {
    /**
     *
     * @type {UsersFollowingCreateResponseData}
     * @memberof UsersFollowingCreateResponse
     */
    data?: UsersFollowingCreateResponseData;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersFollowingCreateResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface UsersFollowingCreateResponseData
 */
export interface UsersFollowingCreateResponseData {
    /**
     *
     * @type {boolean}
     * @memberof UsersFollowingCreateResponseData
     */
    following?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UsersFollowingCreateResponseData
     */
    pending_follow?: boolean;
}
/**
 *
 * @export
 * @interface UsersFollowingDeleteResponse
 */
export interface UsersFollowingDeleteResponse {
    /**
     *
     * @type {UsersFollowingDeleteResponseData}
     * @memberof UsersFollowingDeleteResponse
     */
    data?: UsersFollowingDeleteResponseData;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersFollowingDeleteResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface UsersFollowingDeleteResponseData
 */
export interface UsersFollowingDeleteResponseData {
    /**
     *
     * @type {boolean}
     * @memberof UsersFollowingDeleteResponseData
     */
    following?: boolean;
}
/**
 *
 * @export
 * @interface UsersFollowingLookupResponse
 */
export interface UsersFollowingLookupResponse {
    /**
     *
     * @type {Array<User>}
     * @memberof UsersFollowingLookupResponse
     */
    data?: Array<User>;
    /**
     *
     * @type {Expansions}
     * @memberof UsersFollowingLookupResponse
     */
    includes?: Expansions;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersFollowingLookupResponse
     */
    errors?: Array<Problem>;
    /**
     *
     * @type {GenericMultipleUsersLookupResponseMeta}
     * @memberof UsersFollowingLookupResponse
     */
    meta?: GenericMultipleUsersLookupResponseMeta;
}
/**
 *
 * @export
 * @interface UsersLikesCreateRequest
 */
export interface UsersLikesCreateRequest {
    /**
     *
     * @type {string}
     * @memberof UsersLikesCreateRequest
     */
    tweet_id: string;
}
/**
 *
 * @export
 * @interface UsersLikesCreateResponse
 */
export interface UsersLikesCreateResponse {
    /**
     *
     * @type {UsersLikesCreateResponseData}
     * @memberof UsersLikesCreateResponse
     */
    data?: UsersLikesCreateResponseData;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersLikesCreateResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface UsersLikesCreateResponseData
 */
export interface UsersLikesCreateResponseData {
    /**
     *
     * @type {boolean}
     * @memberof UsersLikesCreateResponseData
     */
    liked?: boolean;
}
/**
 *
 * @export
 * @interface UsersLikesDeleteResponse
 */
export interface UsersLikesDeleteResponse {
    /**
     *
     * @type {UsersLikesCreateResponseData}
     * @memberof UsersLikesDeleteResponse
     */
    data?: UsersLikesCreateResponseData;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersLikesDeleteResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface UsersMutingMutationResponse
 */
export interface UsersMutingMutationResponse {
    /**
     *
     * @type {UsersMutingMutationResponseData}
     * @memberof UsersMutingMutationResponse
     */
    data?: UsersMutingMutationResponseData;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersMutingMutationResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface UsersMutingMutationResponseData
 */
export interface UsersMutingMutationResponseData {
    /**
     *
     * @type {boolean}
     * @memberof UsersMutingMutationResponseData
     */
    muting?: boolean;
}
/**
 *
 * @export
 * @interface UsersRetweetsCreateRequest
 */
export interface UsersRetweetsCreateRequest {
    /**
     *
     * @type {string}
     * @memberof UsersRetweetsCreateRequest
     */
    tweet_id: string;
}
/**
 *
 * @export
 * @interface UsersRetweetsCreateResponse
 */
export interface UsersRetweetsCreateResponse {
    /**
     *
     * @type {UsersRetweetsCreateResponseData}
     * @memberof UsersRetweetsCreateResponse
     */
    data?: UsersRetweetsCreateResponseData;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersRetweetsCreateResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface UsersRetweetsCreateResponseData
 */
export interface UsersRetweetsCreateResponseData {
    /**
     *
     * @type {boolean}
     * @memberof UsersRetweetsCreateResponseData
     */
    retweeted?: boolean;
}
/**
 *
 * @export
 * @interface UsersRetweetsDeleteResponse
 */
export interface UsersRetweetsDeleteResponse {
    /**
     *
     * @type {UsersRetweetsCreateResponseData}
     * @memberof UsersRetweetsDeleteResponse
     */
    data?: UsersRetweetsCreateResponseData;
    /**
     *
     * @type {Array<Problem>}
     * @memberof UsersRetweetsDeleteResponse
     */
    errors?: Array<Problem>;
}
/**
 *
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * The Media Key identifier for this attachment.
     * @type {string}
     * @memberof Video
     */
    media_key?: string;
    /**
     * The height of the media in pixels
     * @type {number}
     * @memberof Video
     */
    height?: number;
    /**
     * The width of the media in pixels
     * @type {number}
     * @memberof Video
     */
    width?: number;
    /**
     *
     * @type {string}
     * @memberof Video
     */
    type?: VideoTypeEnum;
    /**
     *
     * @type {string}
     * @memberof Video
     */
    preview_image_url?: string;
    /**
     *
     * @type {number}
     * @memberof Video
     */
    duration_ms?: number;
    /**
     *
     * @type {VideoAllOfPublicMetrics}
     * @memberof Video
     */
    public_metrics?: VideoAllOfPublicMetrics;
    /**
     *
     * @type {VideoAllOfNonPublicMetrics}
     * @memberof Video
     */
    non_public_metrics?: VideoAllOfNonPublicMetrics;
    /**
     *
     * @type {VideoAllOfOrganicMetrics}
     * @memberof Video
     */
    organic_metrics?: VideoAllOfOrganicMetrics;
    /**
     *
     * @type {VideoAllOfPromotedMetrics}
     * @memberof Video
     */
    promoted_metrics?: VideoAllOfPromotedMetrics;
}

/**
    * @export
    * @enum {string}
    */
export enum VideoTypeEnum {
    Video = 'video'
}

/**
 *
 * @export
 * @interface VideoAllOf
 */
export interface VideoAllOf {
    /**
     *
     * @type {string}
     * @memberof VideoAllOf
     */
    type?: VideoAllOfTypeEnum;
    /**
     *
     * @type {string}
     * @memberof VideoAllOf
     */
    preview_image_url?: string;
    /**
     *
     * @type {number}
     * @memberof VideoAllOf
     */
    duration_ms?: number;
    /**
     *
     * @type {VideoAllOfPublicMetrics}
     * @memberof VideoAllOf
     */
    public_metrics?: VideoAllOfPublicMetrics;
    /**
     *
     * @type {VideoAllOfNonPublicMetrics}
     * @memberof VideoAllOf
     */
    non_public_metrics?: VideoAllOfNonPublicMetrics;
    /**
     *
     * @type {VideoAllOfOrganicMetrics}
     * @memberof VideoAllOf
     */
    organic_metrics?: VideoAllOfOrganicMetrics;
    /**
     *
     * @type {VideoAllOfPromotedMetrics}
     * @memberof VideoAllOf
     */
    promoted_metrics?: VideoAllOfPromotedMetrics;
}

/**
    * @export
    * @enum {string}
    */
export enum VideoAllOfTypeEnum {
    Video = 'video'
}

/**
 * Nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfNonPublicMetrics
 */
export interface VideoAllOfNonPublicMetrics {
    /**
     * Number of users who made it through 0% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    playback_0_count?: number;
    /**
     * Number of users who made it through 25% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    playback_25_count?: number;
    /**
     * Number of users who made it through 50% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    playback_50_count?: number;
    /**
     * Number of users who made it through 75% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    playback_75_count?: number;
    /**
     * Number of users who made it through 100% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    playback_100_count?: number;
}
/**
 * Organic nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfOrganicMetrics
 */
export interface VideoAllOfOrganicMetrics {
    /**
     * Number of users who made it through 0% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    playback_0_count?: number;
    /**
     * Number of users who made it through 25% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    playback_25_count?: number;
    /**
     * Number of users who made it through 50% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    playback_50_count?: number;
    /**
     * Number of users who made it through 75% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    playback_75_count?: number;
    /**
     * Number of users who made it through 100% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    playback_100_count?: number;
    /**
     * Number of times this video has been viewed.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    view_count?: number;
}
/**
 * Promoted nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfPromotedMetrics
 */
export interface VideoAllOfPromotedMetrics {
    /**
     * Number of users who made it through 0% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    playback_0_count?: number;
    /**
     * Number of users who made it through 25% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    playback_25_count?: number;
    /**
     * Number of users who made it through 50% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    playback_50_count?: number;
    /**
     * Number of users who made it through 75% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    playback_75_count?: number;
    /**
     * Number of users who made it through 100% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    playback_100_count?: number;
    /**
     * Number of times this video has been viewed.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    view_count?: number;
}
/**
 * Engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfPublicMetrics
 */
export interface VideoAllOfPublicMetrics {
    /**
     * Number of times this video has been viewed.
     * @type {number}
     * @memberof VideoAllOfPublicMetrics
     */
    view_count?: number;
}

/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
         * @summary Returns the open api spec document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenApiSpec: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/openapi.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = GeneralApiAxiosParamCreator(configuration)
    return {
        /**
         * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
         * @summary Returns the open api spec document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenApiSpec(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenApiSpec(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralApiFp(configuration)
    return {
        /**
         * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
         * @summary Returns the open api spec document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenApiSpec(options?: any): AxiosPromise<object> {
            return localVarFp.getOpenApiSpec(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI {
    /**
     * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     * @summary Returns the open api spec document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public getOpenApiSpec(options?: any) {
        return GeneralApiFp(this.configuration).getOpenApiSpec(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TweetsApi - axios parameter creator
 * @export
 */
export const TweetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
         * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrDeleteRules: async (addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addOrDeleteRulesRequest' is not null or undefined
            assertParamExists('addOrDeleteRules', 'addOrDeleteRulesRequest', addOrDeleteRulesRequest)
            const localVarPath = `/2/tweets/search/stream/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addOrDeleteRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID
         * @summary Tweet lookup by Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetById: async (id: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findTweetById', 'id', id)
            const localVarPath = `/2/tweets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID
         * @summary Tweet lookup by Tweet IDs
         * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetsById: async (ids: Array<string>, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('findTweetsById', 'ids', ids)
            const localVarPath = `/2/tweets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules: async (ids?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/search/stream/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {string} id The ID of the reply that you want to hide or unhide.
         * @param {InlineObject3} [inlineObject3]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideReplyById: async (id: string, inlineObject3?: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hideReplyById', 'id', id)
            const localVarPath = `/2/tweets/{id}/hidden`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sampleStream: async (expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, backfillMinutes?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/sample/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStream: async (expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, backfillMinutes?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/search/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Granularity} [granularity] The granularity for the search counts results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetCountsFullArchiveSearch: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, granularity?: Granularity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tweetCountsFullArchiveSearch', 'query', query)
            const localVarPath = `/2/tweets/counts/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Granularity} [granularity] The granularity for the search counts results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetCountsRecentSearch: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, granularity?: Granularity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tweetCountsRecentSearch', 'query', query)
            const localVarPath = `/2/tweets/counts/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsFullarchiveSearch: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tweetsFullarchiveSearch', 'query', query)
            const localVarPath = `/2/tweets/search/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsRecentSearch: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tweetsRecentSearch', 'query', query)
            const localVarPath = `/2/tweets/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
         * @summary Causes the user (in the path) to like the specified tweet
         * @param {string} id The ID of the user that is requesting to like the tweet
         * @param {UsersLikesCreateRequest} [usersLikesCreateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLike: async (id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdLike', 'id', id)
            const localVarPath = `/2/users/{id}/likes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(usersLikesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {string} id The ID of the User to list the liked Tweets of
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLikedTweets: async (id: string, maxResults?: number, paginationToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdLikedTweets', 'id', id)
            const localVarPath = `/2/users/{id}/liked_tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {string} id The ID of the User to list mentions of
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMentions: async (id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdMentions', 'id', id)
            const localVarPath = `/2/users/{id}/mentions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
         * @summary Causes the user (in the path) to retweet the specified tweet
         * @param {string} id The ID of the user that is requesting to retweet the tweet
         * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRetweets: async (id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdRetweets', 'id', id)
            const localVarPath = `/2/users/{id}/retweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(usersRetweetsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {string} id The ID of the User to list Tweets of
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;)
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdTweets: async (id: string, sinceId?: string, untilId?: string, maxResults?: number, exclude?: Set<'replies' | 'retweets'>, paginationToken?: string, startTime?: string, endTime?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdTweets', 'id', id)
            const localVarPath = `/2/users/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (exclude) {
                localVarQueryParameter['exclude'] = Array.from(exclude).join(COLLECTION_FORMATS.csv);
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
         * @summary Causes the user (in the path) to unlike the specified tweet
         * @param {string} id The ID of the user that is requesting to unlike the tweet
         * @param {string} tweetId The ID of the tweet that the user is requesting to unlike
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnlike: async (id: string, tweetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdUnlike', 'id', id)
            // verify required parameter 'tweetId' is not null or undefined
            assertParamExists('usersIdUnlike', 'tweetId', tweetId)
            const localVarPath = `/2/users/{id}/likes/{tweet_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tweet_id"}}`, encodeURIComponent(String(tweetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
         * @summary Causes the user (in the path) to unretweet the specified tweet
         * @param {string} id The ID of the user that is requesting to unretweet the tweet
         * @param {string} sourceTweetId The ID of the tweet that the user is requesting to unretweet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnretweets: async (id: string, sourceTweetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdUnretweets', 'id', id)
            // verify required parameter 'sourceTweetId' is not null or undefined
            assertParamExists('usersIdUnretweets', 'sourceTweetId', sourceTweetId)
            const localVarPath = `/2/users/{id}/retweets/{source_tweet_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"source_tweet_id"}}`, encodeURIComponent(String(sourceTweetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TweetsApi - functional programming interface
 * @export
 */
export const TweetsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TweetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
         * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrDeleteRules(addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOrDeleteRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID
         * @summary Tweet lookup by Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTweetById(id: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleTweetLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTweetById(id, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID
         * @summary Tweet lookup by Tweet IDs
         * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTweetsById(ids: Array<string>, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultiTweetLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTweetsById(ids, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRules(ids?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRules(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {string} id The ID of the reply that you want to hide or unhide.
         * @param {InlineObject3} [inlineObject3]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideReplyById(id: string, inlineObject3?: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideReplyById(id, inlineObject3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sampleStream(expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, backfillMinutes?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingTweet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sampleStream(expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, backfillMinutes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchStream(expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, backfillMinutes?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilteredStreamingTweet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchStream(expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, backfillMinutes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Granularity} [granularity] The granularity for the search counts results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetCountsFullArchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, granularity?: Granularity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetCountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetCountsFullArchiveSearch(query, startTime, endTime, sinceId, untilId, nextToken, granularity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Granularity} [granularity] The granularity for the search counts results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetCountsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, granularity?: Granularity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetCountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetCountsRecentSearch(query, startTime, endTime, sinceId, untilId, nextToken, granularity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetsFullarchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetsFullarchiveSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetsRecentSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
         * @summary Causes the user (in the path) to like the specified tweet
         * @param {string} id The ID of the user that is requesting to like the tweet
         * @param {UsersLikesCreateRequest} [usersLikesCreateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdLike(id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersLikesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdLike(id, usersLikesCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {string} id The ID of the User to list the liked Tweets of
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdLikedTweets(id: string, maxResults?: number, paginationToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdLikedTweets(id, maxResults, paginationToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {string} id The ID of the User to list mentions of
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdMentions(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericTweetsTimelineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdMentions(id, sinceId, untilId, maxResults, paginationToken, startTime, endTime, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
         * @summary Causes the user (in the path) to retweet the specified tweet
         * @param {string} id The ID of the user that is requesting to retweet the tweet
         * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdRetweets(id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRetweetsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdRetweets(id, usersRetweetsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {string} id The ID of the User to list Tweets of
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;)
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdTweets(id: string, sinceId?: string, untilId?: string, maxResults?: number, exclude?: Set<'replies' | 'retweets'>, paginationToken?: string, startTime?: string, endTime?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericTweetsTimelineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdTweets(id, sinceId, untilId, maxResults, exclude, paginationToken, startTime, endTime, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
         * @summary Causes the user (in the path) to unlike the specified tweet
         * @param {string} id The ID of the user that is requesting to unlike the tweet
         * @param {string} tweetId The ID of the tweet that the user is requesting to unlike
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnlike(id: string, tweetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersLikesDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnlike(id, tweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
         * @summary Causes the user (in the path) to unretweet the specified tweet
         * @param {string} id The ID of the user that is requesting to unretweet the tweet
         * @param {string} sourceTweetId The ID of the tweet that the user is requesting to unretweet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnretweets(id: string, sourceTweetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRetweetsDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnretweets(id, sourceTweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TweetsApi - factory interface
 * @export
 */
export const TweetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TweetsApiFp(configuration)
    return {
        /**
         * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
         * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrDeleteRules(addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options?: any): AxiosPromise<AddOrDeleteRulesResponse> {
            return localVarFp.addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID
         * @summary Tweet lookup by Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetById(id: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): AxiosPromise<SingleTweetLookupResponse> {
            return localVarFp.findTweetById(id, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID
         * @summary Tweet lookup by Tweet IDs
         * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetsById(ids: Array<string>, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): AxiosPromise<MultiTweetLookupResponse> {
            return localVarFp.findTweetsById(ids, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules(ids?: Array<string>, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getRules(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {string} id The ID of the reply that you want to hide or unhide.
         * @param {InlineObject3} [inlineObject3]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideReplyById(id: string, inlineObject3?: InlineObject3, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.hideReplyById(id, inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sampleStream(expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, backfillMinutes?: number, options?: any): AxiosPromise<StreamingTweet> {
            return localVarFp.sampleStream(expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, backfillMinutes, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStream(expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, backfillMinutes?: number, options?: any): AxiosPromise<FilteredStreamingTweet> {
            return localVarFp.searchStream(expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, backfillMinutes, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Granularity} [granularity] The granularity for the search counts results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetCountsFullArchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, granularity?: Granularity, options?: any): AxiosPromise<TweetCountsResponse> {
            return localVarFp.tweetCountsFullArchiveSearch(query, startTime, endTime, sinceId, untilId, nextToken, granularity, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Granularity} [granularity] The granularity for the search counts results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetCountsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, granularity?: Granularity, options?: any): AxiosPromise<TweetCountsResponse> {
            return localVarFp.tweetCountsRecentSearch(query, startTime, endTime, sinceId, untilId, nextToken, granularity, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsFullarchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): AxiosPromise<TweetSearchResponse> {
            return localVarFp.tweetsFullarchiveSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): AxiosPromise<TweetSearchResponse> {
            return localVarFp.tweetsRecentSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
         * @summary Causes the user (in the path) to like the specified tweet
         * @param {string} id The ID of the user that is requesting to like the tweet
         * @param {UsersLikesCreateRequest} [usersLikesCreateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLike(id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options?: any): AxiosPromise<UsersLikesCreateResponse> {
            return localVarFp.usersIdLike(id, usersLikesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {string} id The ID of the User to list the liked Tweets of
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLikedTweets(id: string, maxResults?: number, paginationToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.usersIdLikedTweets(id, maxResults, paginationToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {string} id The ID of the User to list mentions of
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMentions(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): AxiosPromise<GenericTweetsTimelineResponse> {
            return localVarFp.usersIdMentions(id, sinceId, untilId, maxResults, paginationToken, startTime, endTime, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
         * @summary Causes the user (in the path) to retweet the specified tweet
         * @param {string} id The ID of the user that is requesting to retweet the tweet
         * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRetweets(id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options?: any): AxiosPromise<UsersRetweetsCreateResponse> {
            return localVarFp.usersIdRetweets(id, usersRetweetsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {string} id The ID of the User to list Tweets of
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;)
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
         * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdTweets(id: string, sinceId?: string, untilId?: string, maxResults?: number, exclude?: Set<'replies' | 'retweets'>, paginationToken?: string, startTime?: string, endTime?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any): AxiosPromise<GenericTweetsTimelineResponse> {
            return localVarFp.usersIdTweets(id, sinceId, untilId, maxResults, exclude, paginationToken, startTime, endTime, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
         * @summary Causes the user (in the path) to unlike the specified tweet
         * @param {string} id The ID of the user that is requesting to unlike the tweet
         * @param {string} tweetId The ID of the tweet that the user is requesting to unlike
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnlike(id: string, tweetId: string, options?: any): AxiosPromise<UsersLikesDeleteResponse> {
            return localVarFp.usersIdUnlike(id, tweetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
         * @summary Causes the user (in the path) to unretweet the specified tweet
         * @param {string} id The ID of the user that is requesting to unretweet the tweet
         * @param {string} sourceTweetId The ID of the tweet that the user is requesting to unretweet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnretweets(id: string, sourceTweetId: string, options?: any): AxiosPromise<UsersRetweetsDeleteResponse> {
            return localVarFp.usersIdUnretweets(id, sourceTweetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TweetsApi - object-oriented interface
 * @export
 * @class TweetsApi
 * @extends {BaseAPI}
 */
export class TweetsApi extends BaseAPI {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add/Delete rules
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public addOrDeleteRules(addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options?: any) {
        return TweetsApiFp(this.configuration).addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Tweet lookup by Tweet ID
     * @param {string} id A single Tweet ID.
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public findTweetById(id: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any) {
        return TweetsApiFp(this.configuration).findTweetById(id, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Tweet lookup by Tweet IDs
     * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public findTweetsById(ids: Array<string>, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any) {
        return TweetsApiFp(this.configuration).findTweetsById(ids, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Rules lookup
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public getRules(ids?: Array<string>, options?: any) {
        return TweetsApiFp(this.configuration).getRules(ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hides or unhides a reply to an owned conversation.
     * @summary Hide replies
     * @param {string} id The ID of the reply that you want to hide or unhide.
     * @param {InlineObject3} [inlineObject3]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public hideReplyById(id: string, inlineObject3?: InlineObject3, options?: any) {
        return TweetsApiFp(this.configuration).hideReplyById(id, inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams a deterministic 1% of public Tweets.
     * @summary Sample stream
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public sampleStream(expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, backfillMinutes?: number, options?: any) {
        return TweetsApiFp(this.configuration).sampleStream(expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, backfillMinutes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams Tweets matching the stream\'s active rule set.
     * @summary Filtered stream
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public searchStream(expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, backfillMinutes?: number, options?: any) {
        return TweetsApiFp(this.configuration).searchStream(expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, backfillMinutes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet Counts that match a search query.
     * @summary Full archive search counts
     * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Granularity} [granularity] The granularity for the search counts results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public tweetCountsFullArchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, granularity?: Granularity, options?: any) {
        return TweetsApiFp(this.configuration).tweetCountsFullArchiveSearch(query, startTime, endTime, sinceId, untilId, nextToken, granularity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet Counts from the last 7 days that match a search query.
     * @summary Recent search counts
     * @param {string} query One query/rule/filter for matching Tweets. Up to 2048 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Granularity} [granularity] The granularity for the search counts results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public tweetCountsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, granularity?: Granularity, options?: any) {
        return TweetsApiFp(this.configuration).tweetCountsRecentSearch(query, startTime, endTime, sinceId, untilId, nextToken, granularity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweets that match a search query.
     * @summary Full-archive search
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public tweetsFullarchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any) {
        return TweetsApiFp(this.configuration).tweetsFullarchiveSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Recent search
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public tweetsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any) {
        return TweetsApiFp(this.configuration).tweetsRecentSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
     * @summary Causes the user (in the path) to like the specified tweet
     * @param {string} id The ID of the user that is requesting to like the tweet
     * @param {UsersLikesCreateRequest} [usersLikesCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdLike(id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options?: any) {
        return TweetsApiFp(this.configuration).usersIdLike(id, usersLikesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Tweets liked by the provided User ID
     * @summary Returns Tweet objects liked by the provided User ID
     * @param {string} id The ID of the User to list the liked Tweets of
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdLikedTweets(id: string, maxResults?: number, paginationToken?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any) {
        return TweetsApiFp(this.configuration).usersIdLikedTweets(id, maxResults, paginationToken, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet objects that mention username associated to the provided User ID
     * @summary User mention timeline by User ID
     * @param {string} id The ID of the User to list mentions of
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdMentions(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any) {
        return TweetsApiFp(this.configuration).usersIdMentions(id, sinceId, untilId, maxResults, paginationToken, startTime, endTime, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
     * @summary Causes the user (in the path) to retweet the specified tweet
     * @param {string} id The ID of the user that is requesting to retweet the tweet
     * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdRetweets(id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options?: any) {
        return TweetsApiFp(this.configuration).usersIdRetweets(id, usersRetweetsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Tweets authored by the provided User ID
     * @summary User Tweets timeline by User ID
     * @param {string} id The ID of the User to list Tweets of
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results
     * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;)
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdTweets(id: string, sinceId?: string, untilId?: string, maxResults?: number, exclude?: Set<'replies' | 'retweets'>, paginationToken?: string, startTime?: string, endTime?: string, expansions?: Set<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, mediaFields?: Set<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>, placeFields?: Set<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>, pollFields?: Set<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>, options?: any) {
        return TweetsApiFp(this.configuration).usersIdTweets(id, sinceId, untilId, maxResults, exclude, paginationToken, startTime, endTime, expansions, tweetFields, userFields, mediaFields, placeFields, pollFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
     * @summary Causes the user (in the path) to unlike the specified tweet
     * @param {string} id The ID of the user that is requesting to unlike the tweet
     * @param {string} tweetId The ID of the tweet that the user is requesting to unlike
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdUnlike(id: string, tweetId: string, options?: any) {
        return TweetsApiFp(this.configuration).usersIdUnlike(id, tweetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
     * @summary Causes the user (in the path) to unretweet the specified tweet
     * @param {string} id The ID of the user that is requesting to unretweet the tweet
     * @param {string} sourceTweetId The ID of the tweet that the user is requesting to unretweet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdUnretweets(id: string, sourceTweetId: string, options?: any) {
        return TweetsApiFp(this.configuration).usersIdUnretweets(id, sourceTweetId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns information about a user. Specify user by ID.
         * @summary User lookup by ID
         * @param {string} id Required. A User ID.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById: async (id: string, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findUserById', 'id', id)
            const localVarPath = `/2/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about a user. Specify user by username.
         * @summary User lookup by username
         * @param {string} username Required. A username.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByUsername: async (username: string, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('findUserByUsername', 'username', username)
            const localVarPath = `/2/users/by/username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about users. Specify users by their ID.
         * @summary User lookup by IDs
         * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersById: async (ids: Array<string>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('findUsersById', 'ids', ids)
            const localVarPath = `/2/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about users. Specify users by their username.
         * @summary User lookup by usernames
         * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByUsername: async (usernames: Array<string>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'usernames' is not null or undefined
            assertParamExists('findUsersByUsername', 'usernames', usernames)
            const localVarPath = `/2/users/by`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (usernames) {
                localVarQueryParameter['usernames'] = usernames.join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users that have liked the provided Tweet ID
         * @summary Returns user objects that have liked the provided Tweet ID
         * @param {string} id The ID of the Tweet for which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsIdLikingUsers: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tweetsIdLikingUsers', 'id', id)
            const localVarPath = `/2/tweets/{id}/liking_users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users that have retweeted the provided Tweet ID
         * @summary Returns user objects that have retweeted the provided Tweet ID
         * @param {string} id The ID of the Tweet for which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsIdRetweetingUsers: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tweetsIdRetweetingUsers', 'id', id)
            const localVarPath = `/2/tweets/{id}/retweeted_by`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
         * @summary Block User by User ID
         * @param {string} id The ID of the user that is requesting to block the target user
         * @param {InlineObject} [inlineObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBlock: async (id: string, inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdBlock', 'id', id)
            const localVarPath = `/2/users/{id}/blocking`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users that are blocked by the provided user ID
         * @summary Returns user objects that are blocked by provided user ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBlocking: async (id: string, maxResults?: number, paginationToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdBlocking', 'id', id)
            const localVarPath = `/2/users/{id}/blocking`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
         * @summary Follow User
         * @param {string} id The ID of the user that is requesting to follow the target user
         * @param {InlineObject2} [inlineObject2]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollow: async (id: string, inlineObject2?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdFollow', 'id', id)
            const localVarPath = `/2/users/{id}/following`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users that follow the provided user ID
         * @summary Returns user objects that follow the provided user ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollowers: async (id: string, maxResults?: number, paginationToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdFollowers', 'id', id)
            const localVarPath = `/2/users/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of users that are being followed by the provided user ID
         * @summary Following by User ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollowing: async (id: string, maxResults?: number, paginationToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdFollowing', 'id', id)
            const localVarPath = `/2/users/{id}/following`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
         * @summary Mute User by User ID
         * @param {string} id The ID of the user that is requesting to mute the target user
         * @param {InlineObject1} [inlineObject1]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMute: async (id: string, inlineObject1?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdMute', 'id', id)
            const localVarPath = `/2/users/{id}/muting`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
         * @summary Unblock User by User ID
         * @param {string} sourceUserId The ID of the user that is requesting to unblock the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnblock: async (sourceUserId: string, targetUserId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('usersIdUnblock', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('usersIdUnblock', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/blocking/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
         * @summary Unfollow User
         * @param {string} sourceUserId The ID of the user that is requesting to unfollow the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnfollow: async (sourceUserId: string, targetUserId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('usersIdUnfollow', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('usersIdUnfollow', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/following/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
         * @summary Unmute User by User ID
         * @param {string} sourceUserId The ID of the user that is requesting to unmute the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unmute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnmute: async (sourceUserId: string, targetUserId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('usersIdUnmute', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('usersIdUnmute', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/muting/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserToken required



            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns information about a user. Specify user by ID.
         * @summary User lookup by ID
         * @param {string} id Required. A User ID.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserById(id: string, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleUserLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserById(id, expansions, tweetFields, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about a user. Specify user by username.
         * @summary User lookup by username
         * @param {string} username Required. A username.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserByUsername(username: string, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleUserLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserByUsername(username, expansions, tweetFields, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about users. Specify users by their ID.
         * @summary User lookup by IDs
         * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsersById(ids: Array<string>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultiUserLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsersById(ids, expansions, tweetFields, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about users. Specify users by their username.
         * @summary User lookup by usernames
         * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsersByUsername(usernames: Array<string>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultiUserLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsersByUsername(usernames, expansions, tweetFields, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of users that have liked the provided Tweet ID
         * @summary Returns user objects that have liked the provided Tweet ID
         * @param {string} id The ID of the Tweet for which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetsIdLikingUsers(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericMultipleUsersLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetsIdLikingUsers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of users that have retweeted the provided Tweet ID
         * @summary Returns user objects that have retweeted the provided Tweet ID
         * @param {string} id The ID of the Tweet for which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetsIdRetweetingUsers(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericMultipleUsersLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetsIdRetweetingUsers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
         * @summary Block User by User ID
         * @param {string} id The ID of the user that is requesting to block the target user
         * @param {InlineObject} [inlineObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdBlock(id: string, inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersBlockingMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdBlock(id, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of users that are blocked by the provided user ID
         * @summary Returns user objects that are blocked by provided user ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdBlocking(id: string, maxResults?: number, paginationToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericMultipleUsersLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdBlocking(id, maxResults, paginationToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
         * @summary Follow User
         * @param {string} id The ID of the user that is requesting to follow the target user
         * @param {InlineObject2} [inlineObject2]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdFollow(id: string, inlineObject2?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersFollowingCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdFollow(id, inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of users that follow the provided user ID
         * @summary Returns user objects that follow the provided user ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdFollowers(id: string, maxResults?: number, paginationToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericMultipleUsersLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdFollowers(id, maxResults, paginationToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of users that are being followed by the provided user ID
         * @summary Following by User ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdFollowing(id: string, maxResults?: number, paginationToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersFollowingLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdFollowing(id, maxResults, paginationToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
         * @summary Mute User by User ID
         * @param {string} id The ID of the user that is requesting to mute the target user
         * @param {InlineObject1} [inlineObject1]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdMute(id: string, inlineObject1?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersMutingMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdMute(id, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
         * @summary Unblock User by User ID
         * @param {string} sourceUserId The ID of the user that is requesting to unblock the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnblock(sourceUserId: string, targetUserId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersBlockingMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnblock(sourceUserId, targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
         * @summary Unfollow User
         * @param {string} sourceUserId The ID of the user that is requesting to unfollow the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnfollow(sourceUserId: string, targetUserId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersFollowingDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnfollow(sourceUserId, targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
         * @summary Unmute User by User ID
         * @param {string} sourceUserId The ID of the user that is requesting to unmute the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unmute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnmute(sourceUserId: string, targetUserId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersMutingMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnmute(sourceUserId, targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * This endpoint returns information about a user. Specify user by ID.
         * @summary User lookup by ID
         * @param {string} id Required. A User ID.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById(id: string, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any): AxiosPromise<SingleUserLookupResponse> {
            return localVarFp.findUserById(id, expansions, tweetFields, userFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about a user. Specify user by username.
         * @summary User lookup by username
         * @param {string} username Required. A username.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByUsername(username: string, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any): AxiosPromise<SingleUserLookupResponse> {
            return localVarFp.findUserByUsername(username, expansions, tweetFields, userFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about users. Specify users by their ID.
         * @summary User lookup by IDs
         * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersById(ids: Array<string>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any): AxiosPromise<MultiUserLookupResponse> {
            return localVarFp.findUsersById(ids, expansions, tweetFields, userFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about users. Specify users by their username.
         * @summary User lookup by usernames
         * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByUsername(usernames: Array<string>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any): AxiosPromise<MultiUserLookupResponse> {
            return localVarFp.findUsersByUsername(usernames, expansions, tweetFields, userFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users that have liked the provided Tweet ID
         * @summary Returns user objects that have liked the provided Tweet ID
         * @param {string} id The ID of the Tweet for which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsIdLikingUsers(id: string, options?: any): AxiosPromise<GenericMultipleUsersLookupResponse> {
            return localVarFp.tweetsIdLikingUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users that have retweeted the provided Tweet ID
         * @summary Returns user objects that have retweeted the provided Tweet ID
         * @param {string} id The ID of the Tweet for which to return results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsIdRetweetingUsers(id: string, options?: any): AxiosPromise<GenericMultipleUsersLookupResponse> {
            return localVarFp.tweetsIdRetweetingUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
         * @summary Block User by User ID
         * @param {string} id The ID of the user that is requesting to block the target user
         * @param {InlineObject} [inlineObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBlock(id: string, inlineObject?: InlineObject, options?: any): AxiosPromise<UsersBlockingMutationResponse> {
            return localVarFp.usersIdBlock(id, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users that are blocked by the provided user ID
         * @summary Returns user objects that are blocked by provided user ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBlocking(id: string, maxResults?: number, paginationToken?: string, options?: any): AxiosPromise<GenericMultipleUsersLookupResponse> {
            return localVarFp.usersIdBlocking(id, maxResults, paginationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
         * @summary Follow User
         * @param {string} id The ID of the user that is requesting to follow the target user
         * @param {InlineObject2} [inlineObject2]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollow(id: string, inlineObject2?: InlineObject2, options?: any): AxiosPromise<UsersFollowingCreateResponse> {
            return localVarFp.usersIdFollow(id, inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users that follow the provided user ID
         * @summary Returns user objects that follow the provided user ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollowers(id: string, maxResults?: number, paginationToken?: string, options?: any): AxiosPromise<GenericMultipleUsersLookupResponse> {
            return localVarFp.usersIdFollowers(id, maxResults, paginationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of users that are being followed by the provided user ID
         * @summary Following by User ID
         * @param {string} id The ID of the user for whom to return results
         * @param {number} [maxResults] The maximum number of results
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollowing(id: string, maxResults?: number, paginationToken?: string, options?: any): AxiosPromise<UsersFollowingLookupResponse> {
            return localVarFp.usersIdFollowing(id, maxResults, paginationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
         * @summary Mute User by User ID
         * @param {string} id The ID of the user that is requesting to mute the target user
         * @param {InlineObject1} [inlineObject1]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMute(id: string, inlineObject1?: InlineObject1, options?: any): AxiosPromise<UsersMutingMutationResponse> {
            return localVarFp.usersIdMute(id, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
         * @summary Unblock User by User ID
         * @param {string} sourceUserId The ID of the user that is requesting to unblock the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnblock(sourceUserId: string, targetUserId: string, options?: any): AxiosPromise<UsersBlockingMutationResponse> {
            return localVarFp.usersIdUnblock(sourceUserId, targetUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
         * @summary Unfollow User
         * @param {string} sourceUserId The ID of the user that is requesting to unfollow the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnfollow(sourceUserId: string, targetUserId: string, options?: any): AxiosPromise<UsersFollowingDeleteResponse> {
            return localVarFp.usersIdUnfollow(sourceUserId, targetUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
         * @summary Unmute User by User ID
         * @param {string} sourceUserId The ID of the user that is requesting to unmute the target user
         * @param {string} targetUserId The ID of the user that the source user is requesting to unmute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnmute(sourceUserId: string, targetUserId: string, options?: any): AxiosPromise<UsersMutingMutationResponse> {
            return localVarFp.usersIdUnmute(sourceUserId, targetUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * This endpoint returns information about a user. Specify user by ID.
     * @summary User lookup by ID
     * @param {string} id Required. A User ID.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserById(id: string, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any) {
        return UsersApiFp(this.configuration).findUserById(id, expansions, tweetFields, userFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about a user. Specify user by username.
     * @summary User lookup by username
     * @param {string} username Required. A username.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserByUsername(username: string, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any) {
        return UsersApiFp(this.configuration).findUserByUsername(username, expansions, tweetFields, userFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about users. Specify users by their ID.
     * @summary User lookup by IDs
     * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsersById(ids: Array<string>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any) {
        return UsersApiFp(this.configuration).findUsersById(ids, expansions, tweetFields, userFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about users. Specify users by their username.
     * @summary User lookup by usernames
     * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsersByUsername(usernames: Array<string>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>, userFields?: Set<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>, options?: any) {
        return UsersApiFp(this.configuration).findUsersByUsername(usernames, expansions, tweetFields, userFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users that have liked the provided Tweet ID
     * @summary Returns user objects that have liked the provided Tweet ID
     * @param {string} id The ID of the Tweet for which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tweetsIdLikingUsers(id: string, options?: any) {
        return UsersApiFp(this.configuration).tweetsIdLikingUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users that have retweeted the provided Tweet ID
     * @summary Returns user objects that have retweeted the provided Tweet ID
     * @param {string} id The ID of the Tweet for which to return results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tweetsIdRetweetingUsers(id: string, options?: any) {
        return UsersApiFp(this.configuration).tweetsIdRetweetingUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
     * @summary Block User by User ID
     * @param {string} id The ID of the user that is requesting to block the target user
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdBlock(id: string, inlineObject?: InlineObject, options?: any) {
        return UsersApiFp(this.configuration).usersIdBlock(id, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users that are blocked by the provided user ID
     * @summary Returns user objects that are blocked by provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdBlocking(id: string, maxResults?: number, paginationToken?: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdBlocking(id, maxResults, paginationToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
     * @summary Follow User
     * @param {string} id The ID of the user that is requesting to follow the target user
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdFollow(id: string, inlineObject2?: InlineObject2, options?: any) {
        return UsersApiFp(this.configuration).usersIdFollow(id, inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users that follow the provided user ID
     * @summary Returns user objects that follow the provided user ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdFollowers(id: string, maxResults?: number, paginationToken?: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdFollowers(id, maxResults, paginationToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of users that are being followed by the provided user ID
     * @summary Following by User ID
     * @param {string} id The ID of the user for whom to return results
     * @param {number} [maxResults] The maximum number of results
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; or \&#39;previous_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdFollowing(id: string, maxResults?: number, paginationToken?: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdFollowing(id, maxResults, paginationToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
     * @summary Mute User by User ID
     * @param {string} id The ID of the user that is requesting to mute the target user
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdMute(id: string, inlineObject1?: InlineObject1, options?: any) {
        return UsersApiFp(this.configuration).usersIdMute(id, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
     * @summary Unblock User by User ID
     * @param {string} sourceUserId The ID of the user that is requesting to unblock the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdUnblock(sourceUserId: string, targetUserId: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdUnblock(sourceUserId, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
     * @summary Unfollow User
     * @param {string} sourceUserId The ID of the user that is requesting to unfollow the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdUnfollow(sourceUserId: string, targetUserId: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdUnfollow(sourceUserId, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
     * @summary Unmute User by User ID
     * @param {string} sourceUserId The ID of the user that is requesting to unmute the target user
     * @param {string} targetUserId The ID of the user that the source user is requesting to unmute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdUnmute(sourceUserId: string, targetUserId: string, options?: any) {
        return UsersApiFp(this.configuration).usersIdUnmute(sourceUserId, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }
}


